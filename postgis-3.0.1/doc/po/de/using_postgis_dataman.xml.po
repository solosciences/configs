# SOME DESCRIPTIVE TITLE.
#
# Translators:
# Andreas Schild <andreas.schild@bfw.gv.at>, 2017-2019
msgid ""
msgstr ""
"Project-Id-Version: PostGIS\n"
"Report-Msgid-Bugs-To: http://bugs.kde.org\n"
"POT-Creation-Date: 2019-10-06 23:49+0000\n"
"PO-Revision-Date: 2019-03-11 09:35+0000\n"
"Last-Translator: Andreas Schild <andreas.schild@bfw.gv.at>\n"
"Language-Team: German (http://www.transifex.com/postgis/postgis/language/"
"de/)\n"
"Language: de\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"

#. Tag: title
#: using_postgis_dataman.xml:3
#, no-c-format
msgid "Using PostGIS: Data Management and Queries"
msgstr "PostGIS anwenden: Datenverwaltung und Abfragen"

#. Tag: title
#: using_postgis_dataman.xml:6
#, no-c-format
msgid "GIS Objects"
msgstr "GIS Objekte"

#. Tag: para
#: using_postgis_dataman.xml:8
#, no-c-format
msgid ""
"The GIS objects supported by PostGIS are a superset of the \"Simple Features"
"\" defined by the OpenGIS Consortium (OGC). PostGIS supports all the objects "
"and functions specified in the OGC \"Simple Features for SQL\" specification."
msgstr ""
"Die Geoobjekte, die von PostGIS unterstützt werden, sind eine Obermenge der "
"durch das OpenGIS Consortium (OGC) festgelegten \"Simple Features\". PostGIS "
"unterstützt sämtliche Objekte und Funktionen, die in der OGC \"Simple "
"Features for SQL\" Spezifikation normiert sind."

#. Tag: para
#: using_postgis_dataman.xml:13
#, no-c-format
msgid ""
"PostGIS extends the standard with support for 3DZ, 3DM and 4D coordinates."
msgstr ""
"PostGIS erweitert den Standard mit der Unterstützung von 3DZ-, 3DM -und 4D-"
"Koordinaten."

#. Tag: title
#: using_postgis_dataman.xml:17
#, no-c-format
msgid "OpenGIS WKB and WKT"
msgstr "OpenGIS WKB und WKT"

#. Tag: para
#: using_postgis_dataman.xml:19
#, no-c-format
msgid ""
"The OpenGIS specification defines two standard ways of expressing spatial "
"objects: the Well-Known Text (WKT) form and the Well-Known Binary (WKB) "
"form. Both WKT and WKB include information about the type of the object and "
"the coordinates which form the object."
msgstr ""
"Die OpenGIS Spezifikation standardisiert zwei Möglichkeiten um Geoobjekte "
"darzustellen: die Well-known-Text (WKT) und die Well-Known-Binary (WKB) "
"Darstellung. Sowohl WKT als auch WKB enthalten Information über den "
"Objekttyp und die Koordinaten, die das Objekt bilden."

#. Tag: para
#: using_postgis_dataman.xml:24
#, no-c-format
msgid ""
"Examples of the text representations (WKT) of the spatial objects of the "
"features are as follows:"
msgstr "Beispiele für die Textdarstellung (WKT) von Geoobjekten:"

#. Tag: para
#: using_postgis_dataman.xml:29
#, no-c-format
msgid "POINT(0 0)"
msgstr "POINT(0 0)"

#. Tag: para
#: using_postgis_dataman.xml:33
#, no-c-format
msgid "LINESTRING(0 0,1 1,1 2)"
msgstr "LINESTRING(0 0,1 1,1 2)"

#. Tag: para
#: using_postgis_dataman.xml:37
#, no-c-format
msgid "POLYGON((0 0,4 0,4 4,0 4,0 0),(1 1, 2 1, 2 2, 1 2,1 1))"
msgstr "POLYGON((0 0,4 0,4 4,0 4,0 0),(1 1, 2 1, 2 2, 1 2,1 1))"

#. Tag: para
#: using_postgis_dataman.xml:41
#, no-c-format
msgid "MULTIPOINT((0 0),(1 2))"
msgstr "MULTIPOINT((0 0),(1 2))"

#. Tag: para
#: using_postgis_dataman.xml:45
#, no-c-format
msgid "MULTILINESTRING((0 0,1 1,1 2),(2 3,3 2,5 4))"
msgstr "MULTILINESTRING((0 0,1 1,1 2),(2 3,3 2,5 4))"

#. Tag: para
#: using_postgis_dataman.xml:49
#, no-c-format
msgid ""
"MULTIPOLYGON(((0 0,4 0,4 4,0 4,0 0),(1 1,2 1,2 2,1 2,1 1)), ((-1 -1,-1 -2,-2 "
"-2,-2 -1,-1 -1)))"
msgstr ""
"MULTIPOLYGON(((0 0,4 0,4 4,0 4,0 0),(1 1,2 1,2 2,1 2,1 1)), ((-1 -1,-1 -2,-2 "
"-2,-2 -1,-1 -1)))"

#. Tag: para
#: using_postgis_dataman.xml:54
#, no-c-format
msgid "GEOMETRYCOLLECTION(POINT(2 3),LINESTRING(2 3,3 4))"
msgstr "GEOMETRYCOLLECTION(POINT(2 3),LINESTRING(2 3,3 4))"

#. Tag: para
#: using_postgis_dataman.xml:58
#, no-c-format
msgid ""
"The OpenGIS specification also requires that the internal storage format of "
"spatial objects include a spatial referencing system identifier (SRID). The "
"SRID is required when creating spatial objects for insertion into the "
"database."
msgstr ""
"Die OpenGIS Spezifikation verlangt auch, dass das der Identifikator des "
"Koordinatenreferenzsystem (SRID) im internen Format der Geoobjekte mit "
"abgespeichert ist."

#. Tag: para
#: using_postgis_dataman.xml:63
#, no-c-format
msgid ""
"Input/Output of these formats are available using the following interfaces:"
msgstr ""
"Für die Ein- und Ausgabe dieser Formate stehen die folgenden Schnittstellen "
"zur Verfügung"

#. Tag: programlisting
#: using_postgis_dataman.xml:66
#, no-c-format
msgid ""
"bytea WKB = ST_AsBinary(geometry);\n"
"text WKT = ST_AsText(geometry);\n"
"geometry = ST_GeomFromWKB(bytea WKB, SRID);\n"
"geometry = ST_GeometryFromText(text WKT, SRID);"
msgstr ""
"bytea WKB = ST_AsBinary(geometry);\n"
"text WKT = ST_AsText(geometry);\n"
"geometry = ST_GeomFromWKB(bytea WKB, SRID);\n"
"geometry = ST_GeometryFromText(text WKT, SRID);"

#. Tag: para
#: using_postgis_dataman.xml:68
#, no-c-format
msgid ""
"For example, a valid insert statement to create and insert an OGC spatial "
"object would be:"
msgstr ""
"Eine gültige Einfügeanweisung, um ein räumliches OGC-Objekt zu erzeugen und "
"einzufügen, wäre:"

#. Tag: programlisting
#: using_postgis_dataman.xml:71
#, no-c-format
msgid ""
"INSERT INTO geotable ( the_geom, the_name )\n"
"  VALUES ( ST_GeomFromText('POINT(-126.4 45.32)', 312), 'A Place');"
msgstr ""
"INSERT INTO geotable ( the_geom, the_name )\n"
"  VALUES ( ST_GeomFromText('POINT(-126.4 45.32)', 312), 'A Place');"

#. Tag: title
#: using_postgis_dataman.xml:75
#, no-c-format
msgid "PostGIS EWKB, EWKT and Canonical Forms"
msgstr "PostGIS EWKB, EWKT und Normalformen/kanonische Formen"

#. Tag: para
#: using_postgis_dataman.xml:77
#, no-c-format
msgid ""
"OGC formats only support 2D geometries, and the associated SRID is *never* "
"embedded in the input/output representations."
msgstr ""
"Das OGC Format unterstützt nur 2D-Geometrien, und die dazugehörige SRID ist "
"*niemals* in den Eingabe/Ausgabe-Darstellungen eingebettet."

#. Tag: para
#: using_postgis_dataman.xml:80
#, no-c-format
msgid ""
"PostGIS extended formats are currently superset of OGC one (every valid WKB/"
"WKT is a valid EWKB/EWKT) but this might vary in the future, specifically if "
"OGC comes out with a new format conflicting with our extensions. Thus you "
"SHOULD NOT rely on this feature!"
msgstr ""
"Zur Zeit sind die erweiterten Formate von PostGIS eine Obermenge von den OGC-"
"Formaten (jeder gültige WKT/WKB ist auch ein gültiger EWKT/EWKB). Dies kann "
"sich in der Zukunft allerdings ändern, insbesondere dann, wenn OGC ein neues "
"Format einführt, welches mit diesen Erweiterungen im Widerspruch steht. "
"Daher sollten SIE sich BITTE NICHT auf diese Eigenschaft verlassen!"

#. Tag: para
#: using_postgis_dataman.xml:85
#, no-c-format
msgid ""
"PostGIS EWKB/EWKT add 3DM, 3DZ, 4D coordinates support and embedded SRID "
"information."
msgstr ""
"PostGIS EWKB/EWKT add 3DM, 3DZ, 4D coordinates support and embedded SRID "
"information."

#. Tag: para
#: using_postgis_dataman.xml:88
#, no-c-format
msgid ""
"Examples of the text representations (EWKT) of the extended spatial objects "
"of the features are as follows."
msgstr "Beispiele für die Textdarstellung (EWKT) von erweiterten Geoobjekten:"

#. Tag: para
#: using_postgis_dataman.xml:93
#, no-c-format
msgid "POINT(0 0 0) -- XYZ"
msgstr "POINT(0 0 0) -- XYZ"

#. Tag: para
#: using_postgis_dataman.xml:97
#, no-c-format
msgid "SRID=32632;POINT(0 0) -- XY with SRID"
msgstr "SRID=32632;POINT(0 0) -- XY mit SRID"

#. Tag: para
#: using_postgis_dataman.xml:101
#, no-c-format
msgid "POINTM(0 0 0) -- XYM"
msgstr "POINTM(0 0 0) -- XYM"

#. Tag: para
#: using_postgis_dataman.xml:105
#, no-c-format
msgid "POINT(0 0 0 0) -- XYZM"
msgstr "POINT(0 0 0 0) -- XYZM"

#. Tag: para
#: using_postgis_dataman.xml:109
#, no-c-format
msgid "SRID=4326;MULTIPOINTM(0 0 0,1 2 1) -- XYM with SRID"
msgstr "SRID=4326;MULTIPOINTM(0 0 0,1 2 1) -- XYM mit SRID"

#. Tag: para
#: using_postgis_dataman.xml:113
#, no-c-format
msgid "MULTILINESTRING((0 0 0,1 1 0,1 2 1),(2 3 1,3 2 1,5 4 1))"
msgstr "MULTILINESTRING((0 0 0,1 1 0,1 2 1),(2 3 1,3 2 1,5 4 1))"

#. Tag: para
#: using_postgis_dataman.xml:118
#, no-c-format
msgid ""
"POLYGON((0 0 0,4 0 0,4 4 0,0 4 0,0 0 0),(1 1 0,2 1 0,2 2 0,1 2 0,1 1 0))"
msgstr ""
"POLYGON((0 0 0,4 0 0,4 4 0,0 4 0,0 0 0),(1 1 0,2 1 0,2 2 0,1 2 0,1 1 0))"

#. Tag: para
#: using_postgis_dataman.xml:123
#, no-c-format
msgid ""
"MULTIPOLYGON(((0 0 0,4 0 0,4 4 0,0 4 0,0 0 0),(1 1 0,2 1 0,2 2 0,1 2 0,1 1 "
"0)),((-1 -1 0,-1 -2 0,-2 -2 0,-2 -1 0,-1 -1 0)))"
msgstr ""
"MULTIPOLYGON(((0 0 0,4 0 0,4 4 0,0 4 0,0 0 0),(1 1 0,2 1 0,2 2 0,1 2 0,1 1 "
"0)),((-1 -1 0,-1 -2 0,-2 -2 0,-2 -1 0,-1 -1 0)))"

#. Tag: para
#: using_postgis_dataman.xml:128
#, no-c-format
msgid "GEOMETRYCOLLECTIONM( POINTM(2 3 9), LINESTRINGM(2 3 4, 3 4 5) )"
msgstr "GEOMETRYCOLLECTIONM( POINTM(2 3 9), LINESTRINGM(2 3 4, 3 4 5) )"

#. Tag: para
#: using_postgis_dataman.xml:132
#, no-c-format
msgid "MULTICURVE( (0 0, 5 5), CIRCULARSTRING(4 0, 4 4, 8 4) )"
msgstr "MULTICURVE( (0 0, 5 5), CIRCULARSTRING(4 0, 4 4, 8 4) )"

#. Tag: para
#: using_postgis_dataman.xml:136
#, no-c-format
msgid ""
"POLYHEDRALSURFACE( ((0 0 0, 0 0 1, 0 1 1, 0 1 0, 0 0 0)), ((0 0 0, 0 1 0, 1 "
"1 0, 1 0 0, 0 0 0)), ((0 0 0, 1 0 0, 1 0 1, 0 0 1, 0 0 0)), ((1 1 0, 1 1 1, "
"1 0 1, 1 0 0, 1 1 0)), ((0 1 0, 0 1 1, 1 1 1, 1 1 0, 0 1 0)), ((0 0 1, 1 0 "
"1, 1 1 1, 0 1 1, 0 0 1)) )"
msgstr ""
"POLYHEDRALSURFACE( ((0 0 0, 0 0 1, 0 1 1, 0 1 0, 0 0 0)), ((0 0 0, 0 1 0, 1 "
"1 0, 1 0 0, 0 0 0)), ((0 0 0, 1 0 0, 1 0 1, 0 0 1, 0 0 0)), ((1 1 0, 1 1 1, "
"1 0 1, 1 0 0, 1 1 0)), ((0 1 0, 0 1 1, 1 1 1, 1 1 0, 0 1 0)), ((0 0 1, 1 0 "
"1, 1 1 1, 0 1 1, 0 0 1)) )"

#. Tag: para
#: using_postgis_dataman.xml:142
#, no-c-format
msgid "TRIANGLE ((0 0, 0 9, 9 0, 0 0))"
msgstr "TRIANGLE ((0 0, 0 9, 9 0, 0 0))"

#. Tag: para
#: using_postgis_dataman.xml:146
#, no-c-format
msgid "TIN( ((0 0 0, 0 0 1, 0 1 0, 0 0 0)), ((0 0 0, 0 1 0, 1 1 0, 0 0 0)) )"
msgstr "TIN( ((0 0 0, 0 0 1, 0 1 0, 0 0 0)), ((0 0 0, 0 1 0, 1 1 0, 0 0 0)) )"

#. Tag: para
#: using_postgis_dataman.xml:151
#, no-c-format
msgid ""
"Conversion between these formats is available using the following interfaces:"
msgstr ""
"Für die Konvertierung zwischen diesen Formaten stehen die folgenden "
"Schnittstellen zur Verfügung:"

#. Tag: programlisting
#: using_postgis_dataman.xml:153
#, no-c-format
msgid ""
"bytea EWKB = ST_AsEWKB(geometry);\n"
"text EWKT = ST_AsEWKT(geometry);\n"
"geometry = ST_GeomFromEWKB(bytea EWKB);\n"
"geometry = ST_GeomFromEWKT(text EWKT);"
msgstr ""
"bytea EWKB = ST_AsEWKB(geometry);\n"
"text EWKT = ST_AsEWKT(geometry);\n"
"geometry = ST_GeomFromEWKB(bytea EWKB);\n"
"geometry = ST_GeomFromEWKT(text EWKT);"

#. Tag: para
#: using_postgis_dataman.xml:155
#, no-c-format
msgid ""
"For example, a valid insert statement to create and insert a PostGIS spatial "
"object would be:"
msgstr ""
"Zum Beispiel würde eine gültige Eingabeanweisung, um räumliche PostGIS "
"Objekte zu erzeugen und einzufügen, wie folgt lauten:"

#. Tag: programlisting
#: using_postgis_dataman.xml:158
#, no-c-format
msgid ""
"INSERT INTO geotable ( the_geom, the_name )\n"
"  VALUES ( ST_GeomFromEWKT('SRID=312;POINTM(-126.4 45.32 15)'), 'A Place' )"
msgstr ""
"INSERT INTO geotable ( the_geom, the_name )\n"
"  VALUES ( ST_GeomFromEWKT('SRID=312;POINTM(-126.4 45.32 15)'), 'A Place' )"

#. Tag: para
#: using_postgis_dataman.xml:160
#, no-c-format
msgid ""
"The \"canonical forms\" of a PostgreSQL type are the representations you get "
"with a simple query (without any function call) and the one which is "
"guaranteed to be accepted with a simple insert, update or copy. For the "
"PostGIS 'geometry' type these are:"
msgstr ""
"Die \"kanonische Form\" eines PostgreSQL Datentyps ist jene Darstellung die "
"man mit einer einfachen Abfrage (ohne Funktionsaufruf) erhält und bei der "
"sichergestellt ist, dass sie von einem einfachen INSERT, UPDATE oder COPY "
"angenommen wird. Beim geometrischen Datentyp von PostGIS sind dies:"

#. Tag: programlisting
#: using_postgis_dataman.xml:164
#, no-c-format
msgid ""
"- Output\n"
"  - binary: EWKB\n"
"        ascii: HEXEWKB (EWKB in hex form)\n"
"- Input\n"
"  - binary: EWKB\n"
"        ascii: HEXEWKB|EWKT"
msgstr ""
"- Ausgabe\n"
"  - binary: EWKB\n"
"        ascii: HEXEWKB (EWKB in hex form)\n"
"- Eingabe\n"
"  - binary: EWKB\n"
"        ascii: HEXEWKB|EWKT"

#. Tag: para
#: using_postgis_dataman.xml:166
#, no-c-format
msgid ""
"For example this statement reads EWKT and returns HEXEWKB in the process of "
"canonical ascii input/output:"
msgstr ""
"Zum Beispiel liest die folgende Anweisung EWKT ein und gibt HEXEWKB in "
"Normalform aus:"

#. Tag: programlisting
#: using_postgis_dataman.xml:169
#, no-c-format
msgid ""
"=# SELECT 'SRID=4;POINT(0 0)'::geometry;\n"
"\n"
"geometry\n"
"----------------------------------------------------\n"
"01010000200400000000000000000000000000000000000000\n"
"(1 row)"
msgstr ""
"=# SELECT 'SRID=4;POINT(0 0)'::geometry;\n"
"\n"
"geometry\n"
"----------------------------------------------------\n"
"01010000200400000000000000000000000000000000000000\n"
"(1 row)"

#. Tag: title
#: using_postgis_dataman.xml:172
#, no-c-format
msgid "SQL-MM Part 3"
msgstr "SQL-MM Part 3"

#. Tag: para
#: using_postgis_dataman.xml:174
#, no-c-format
msgid ""
"The SQL Multimedia Applications Spatial specification extends the simple "
"features for SQL spec by defining a number of circularly interpolated curves."
msgstr ""
"Die \"SQL Multimedia Applications Spatial\" Spezifikation erweitert die SQL "
"Spezifikation für Simple Features indem es eine Reihe von kreisförmig "
"interpolierten Kurven definiert."

#. Tag: para
#: using_postgis_dataman.xml:178
#, no-c-format
msgid ""
"The SQL-MM definitions include 3DM, 3DZ and 4D coordinates, but do not allow "
"the embedding of SRID information."
msgstr ""
"Die Definitionen in SQL-MM schließen 3DM-, 3DZ- und 4D-Koordinaten ein, "
"erlauben allerdings nicht das Einbinden von Information über SRID."

#. Tag: para
#: using_postgis_dataman.xml:181
#, no-c-format
msgid ""
"The Well-Known Text extensions are not yet fully supported. Examples of some "
"simple curved geometries are shown below:"
msgstr ""
"Die Erweiterungen zur Well-known-Text-Darstellung werden zur Zeit noch nicht "
"zur Gänze unterstützt. Im Folgenden werden Beispiele für einige einfache "
"gekrümmte Geometrien gezeigt:"

#. Tag: para
#: using_postgis_dataman.xml:186
#, no-c-format
msgid "CIRCULARSTRING(0 0, 1 1, 1 0)"
msgstr "CIRCULARSTRING(0 0, 1 1, 1 0)"

#. Tag: para
#: using_postgis_dataman.xml:187
#, no-c-format
msgid "CIRCULARSTRING(0 0, 4 0, 4 4, 0 4, 0 0)"
msgstr "CIRCULARSTRING(0 0, 4 0, 4 4, 0 4, 0 0)"

#. Tag: para
#: using_postgis_dataman.xml:188
#, no-c-format
msgid ""
"The CIRCULARSTRING is the basic curve type, similar to a LINESTRING in the "
"linear world. A single segment required three points, the start and end "
"points (first and third) and any other point on the arc. The exception to "
"this is for a closed circle, where the start and end points are the same. In "
"this case the second point MUST be the center of the arc, ie the opposite "
"side of the circle. To chain arcs together, the last point of the previous "
"arc becomes the first point of the next arc, just like in LINESTRING. This "
"means that a valid circular string must have an odd number of points greater "
"than 1."
msgstr ""
"CIRCULARSTRING ist der grundlegende Kurventyp, ähnlich wie LINESTRING in der "
"linearen Welt. Ein einziges Segment benötigt drei Punkte, den Anfangs- und "
"den Endpunkt (erster und dritter) und irgendeinen weiterer Punkt auf dem "
"Kreisbogen. Eine Ausnahme ist der geschlossene Kreis, wo Anfangs- und "
"Endpunkt ident sind. In diesem Fall muss der zweite Punkt dem "
"Kreismittelpunkt entsprechen. Um Kreisbögen aneinanderzuketten, wird der "
"Endpunkt des vorangehenden Bogens zum Anfangspunkt des nächstfolgenden "
"Bogens, genauso wie beim LINESTRING. D.h., dass ein Kreisbogen eine ungerade "
"Anzahl an Punkten grösser als 1 aufweisen muss."

#. Tag: para
#: using_postgis_dataman.xml:201
#, no-c-format
msgid "COMPOUNDCURVE(CIRCULARSTRING(0 0, 1 1, 1 0),(1 0, 0 1))"
msgstr "COMPOUNDCURVE(CIRCULARSTRING(0 0, 1 1, 1 0),(1 0, 0 1))"

#. Tag: para
#: using_postgis_dataman.xml:202
#, no-c-format
msgid ""
"A compound curve is a single, continuous curve that has both curved "
"(circular) segments and linear segments. That means that in addition to "
"having well-formed components, the end point of every component (except the "
"last) must be coincident with the start point of the following component."
msgstr ""
"Eine zusammengesetzte Kurve ist eine einzelne, durchgängige Kurve, die "
"sowohl gekrümmte (kreisförmige) als auch gerade Segmente aufweist. Dies "
"bedeutet, daß die Komponenten nicht nur wohlgeformt sein müssen, sondern "
"auch der Endpunkt einer jeden Komponente (außer der letzten) mit dem "
"Anfangspunkt der nachfolgenden Komponente zusammenfallen muss."

#. Tag: para
#: using_postgis_dataman.xml:210
#, no-c-format
msgid ""
"CURVEPOLYGON(CIRCULARSTRING(0 0, 4 0, 4 4, 0 4, 0 0),(1 1, 3 3, 3 1, 1 1))"
msgstr ""
"CURVEPOLYGON(CIRCULARSTRING(0 0, 4 0, 4 4, 0 4, 0 0),(1 1, 3 3, 3 1, 1 1))"

#. Tag: para
#: using_postgis_dataman.xml:212
#, no-c-format
msgid ""
"Example compound curve in a curve polygon: "
"CURVEPOLYGON(COMPOUNDCURVE(CIRCULARSTRING(0 0,2 0, 2 1, 2 3, 4 3),(4 3, 4 5, "
"1 4, 0 0)), CIRCULARSTRING(1.7 1, 1.4 0.4, 1.6 0.4, 1.6 0.5, 1.7 1) )"
msgstr ""
"Beispiel einer zusammengesetzten Kurve in einem Kurvenpolygon: "
"CURVEPOLYGON(COMPOUNDCURVE(CIRCULARSTRING(0 0,2 0, 2 1, 2 3, 4 3),(4 3, 4 5, "
"1 4, 0 0)), CIRCULARSTRING(1.7 1, 1.4 0.4, 1.6 0.4, 1.6 0.5, 1.7 1) )"

#. Tag: para
#: using_postgis_dataman.xml:216
#, no-c-format
msgid ""
"A CURVEPOLYGON is just like a polygon, with an outer ring and zero or more "
"inner rings. The difference is that a ring can take the form of a circular "
"string, linear string or compound string."
msgstr ""
"Ein CurvePolygon hat, genau wie ein Polygon, einen äußeren Ring und keinen "
"oder mehrere innere Ringe. Der Unterschied liegt darin, dass ein Ring aus "
"Kreisbögen, Geraden oder zusammengesetzten Strecken bestehen kann."

#. Tag: para
#: using_postgis_dataman.xml:220
#, no-c-format
msgid "As of PostGIS 1.4 PostGIS supports compound curves in a curve polygon."
msgstr ""
"Ab PostGIS 1.4 werden zusammengesetzte Kurven/CompoundCurve in einem "
"Kurvenpolygon/CurvePolygon unterstützt."

#. Tag: para
#: using_postgis_dataman.xml:224
#, no-c-format
msgid "MULTICURVE((0 0, 5 5),CIRCULARSTRING(4 0, 4 4, 8 4))"
msgstr "MULTICURVE((0 0, 5 5),CIRCULARSTRING(4 0, 4 4, 8 4))"

#. Tag: para
#: using_postgis_dataman.xml:225
#, no-c-format
msgid ""
"The MULTICURVE is a collection of curves, which can include linear strings, "
"circular strings or compound strings."
msgstr ""
"Eine MultiCurve ist eine Sammelgeometrie von Kurven, welche aus Geraden, "
"Kreisabschnitte oder zusammengesetzten Abschnitten bestehen kann."

#. Tag: para
#: using_postgis_dataman.xml:230
#, no-c-format
msgid ""
"MULTISURFACE(CURVEPOLYGON(CIRCULARSTRING(0 0, 4 0, 4 4, 0 4, 0 0),(1 1, 3 3, "
"3 1, 1 1)),((10 10, 14 12, 11 10, 10 10),(11 11, 11.5 11, 11 11.5, 11 11)))"
msgstr ""
"MULTISURFACE(CURVEPOLYGON(CIRCULARSTRING(0 0, 4 0, 4 4, 0 4, 0 0),(1 1, 3 3, "
"3 1, 1 1)),((10 10, 14 12, 11 10, 10 10),(11 11, 11.5 11, 11 11.5, 11 11)))"

#. Tag: para
#: using_postgis_dataman.xml:233
#, no-c-format
msgid ""
"This is a collection of surfaces, which can be (linear) polygons or curve "
"polygons."
msgstr ""
"Dies ist eine Sammelgeometrie von Oberflächen, welche (lineare) Polygone "
"oder Kurvenpolygone sein können."

#. Tag: para
#: using_postgis_dataman.xml:239
#, no-c-format
msgid ""
"All floating point comparisons within the SQL-MM implementation are "
"performed to a specified tolerance, currently 1E-8."
msgstr ""
"Alle Gleitpunkt Vergleiche der SQL-MM Implementierung werden mit einer "
"bestimmten Toleranz ausgeführt, zurzeit 1E-8."

#. Tag: title
#: using_postgis_dataman.xml:245
#, no-c-format
msgid "PostGIS Geography Type"
msgstr "Der geographische Datentyp von PostGIS"

#. Tag: para
#: using_postgis_dataman.xml:247
#, no-c-format
msgid ""
"The geography type provides native support for spatial features represented "
"on \"geographic\" coordinates (sometimes called \"geodetic\" coordinates, or "
"\"lat/lon\", or \"lon/lat\"). Geographic coordinates are spherical "
"coordinates expressed in angular units (degrees)."
msgstr ""
"Der geographische Datentyp bietet native Unterstützung für Geoobjekte die "
"durch \"geographische\" Koordinaten (manchmal auch als \"geodätische\" "
"Koordinaten, \"Länge/Breite\" oder \"Breite/Länge\" bezeichnet) festgelegt "
"sind. Geographische Koordinaten sind Kugelkoordinaten, die durch Winkel (in "
"Grad) angegeben werden."

#. Tag: para
#: using_postgis_dataman.xml:249
#, no-c-format
msgid ""
"The basis for the PostGIS geometry type is a plane. The shortest path "
"between two points on the plane is a straight line. That means calculations "
"on geometries (areas, distances, lengths, intersections, etc) can be "
"calculated using cartesian mathematics and straight line vectors."
msgstr ""
"Der geometrische Datentyp von PostGIS beruht auf der Ebene. Die kürzeste "
"Entfernung zwischen zwei Punkten einer Ebene entspricht einer Gerade. Das "
"bedeutet, dass geometrische Berechnungen (wie Flächen, Distanzen, Längen, "
"Schnittpunkte, etc.) im kartesischen Koordinatensystem mit geradlinigen "
"Vektoren ausgeführt werden können."

#. Tag: para
#: using_postgis_dataman.xml:251
#, no-c-format
msgid ""
"The basis for the PostGIS geographic type is a sphere. The shortest path "
"between two points on the sphere is a great circle arc. That means that "
"calculations on geographies (areas, distances, lengths, intersections, etc) "
"must be calculated on the sphere, using more complicated mathematics. For "
"more accurate measurements, the calculations must take the actual spheroidal "
"shape of the world into account."
msgstr ""
"Der geographische Datentyp von PostGIS beruht auf einer Kugel. Die kürzeste "
"Verbindung zwischen zwei Punkten auf einer Kugeloberfläche ist ein Bogenteil "
"eines Großkreises. D.h., dass Berechnungen auf geographische Datentypen (wie "
"Flächen, Distanzen, Längen, Schnittpunkte, etc.) auf der Kugeloberfläche mit "
"einer komplexeren Mathematik durchgeführt werden müssen. Für genauere "
"Messungen müssen die Berechnungen das Rotationsellipsoid der Erde in "
"Betracht ziehen."

#. Tag: para
#: using_postgis_dataman.xml:253
#, no-c-format
msgid ""
"Because the underlying mathematics is much more complicated, there are fewer "
"functions defined for the geography type than for the geometry type. Over "
"time, as new algorithms are added, the capabilities of the geography type "
"will expand."
msgstr ""
"Da die zugrunde liegende Mathematik wesentlich schwieriger ist, gibt es "
"weniger Funktionen für den geographischen Datentyp, als für den "
"geometrischen Datentyp. Mit der Zeit werden neue Algorithmen hinugefügt und "
"die Möglichkeiten des geographischen Datentyps erweitert werden."

#. Tag: para
#: using_postgis_dataman.xml:255
#, no-c-format
msgid ""
"It uses a data type called <varname>geography</varname>. None of the GEOS "
"functions support the <varname>geography</varname> type. As a workaround one "
"can convert back and forth between geometry and geography types."
msgstr ""
"Es verwendet den Datentyp <varname>geography</varname>, der allerdings von "
"den Funktionen der Bibliothek GEOS in keiner Weise unterstützt wird. Als "
"provisorische Lösung kann man zwischen dem geometrischen und dem "
"geographischen Datentypen hin- und herkonvertieren."

#. Tag: para
#: using_postgis_dataman.xml:258
#, no-c-format
msgid ""
"Prior to PostGIS 2.2, the geography type only supported WGS 84 long lat "
"(SRID:4326). For PostGIS 2.2 and above, any long/lat based spatial reference "
"system defined in the <varname>spatial_ref_sys</varname> table can be used. "
"You can even add your own custom spheroidal spatial reference system as "
"described in <ulink url=\"http://www.bostongis.com/blog/index.php?/"
"archives/266-geography-type-is-not-limited-to-earth.html\">geography type is "
"not limited to earth</ulink>."
msgstr ""
"Vor PostGIS 2.2 hat der geographische Datentyp nur WGS 84 Länge und Breite "
"(SRID:4326) unterstützt. Ab PostGIS 2.2 kann dieser jedes "
"Koordinatenreferenzsystem verwenden, das auf Länge und Breite basiert und in "
"der Tabelle <varname>spatial_ref_sys</varname>aufgeführt ist. Sie können "
"sogar Ihr eigenes Polarkoordinatenreferenzsystem hinzufügen, wie unter "
"<ulink url=\"http://www.bostongis.com/blog/index.php?/archives/266-geography-"
"type-is-not-limited-to-earth.html\">geography type is not limited to earth</"
"ulink> beschrieben."

#. Tag: para
#: using_postgis_dataman.xml:262
#, no-c-format
msgid ""
"Regardless which spatial reference system you use, the units returned by the "
"measurement (<xref linkend=\"ST_Distance\"/>, <xref linkend=\"ST_Length\"/>, "
"<xref linkend=\"ST_Perimeter\"/>, <xref linkend=\"ST_Area\"/>) and for input "
"of <xref linkend=\"ST_DWithin\"/> are in meters."
msgstr ""
"Unabhängig vom verwendeten Koordinatenreferenzsystem sind die Einheiten der "
"ausgegebenen Messungen (<xref linkend=\"ST_Distance\"/>, <xref linkend="
"\"ST_Length\"/>, <xref linkend=\"ST_Perimeter\"/>, <xref linkend=\"ST_Area\"/"
">) und der Eingabe für <xref linkend=\"ST_DWithin\"/> in Meter."

#. Tag: para
#: using_postgis_dataman.xml:264
#, no-c-format
msgid ""
"The geography type uses the PostgreSQL typmod definition format so that a "
"table with a geography field can be added in a single step. All the standard "
"OGC formats except for curves are supported."
msgstr ""
"Der geographische Datentyp verwendet die Typmod-Formatangabe von PostgreSQL, "
"sodass eine Tabelle mit einem geographischen Attribut in einem einzigen "
"Schritt erstellt werden kann. Es werden alle Formate des OGC-Standards "
"unterstützt, mit Ausnahme von Kurven."

#. Tag: title
#: using_postgis_dataman.xml:268
#, no-c-format
msgid "Geography Basics"
msgstr "Grundsätzliches zum geographischen Datentyp"

#. Tag: para
#: using_postgis_dataman.xml:269
#, no-c-format
msgid ""
"The geography type does not support curves, TINS, or POLYHEDRALSURFACEs, but "
"other geometry types are supported. Standard geometry type data will "
"autocast to geography if it is of SRID 4326. You can also use the EWKT and "
"EWKB conventions to insert data."
msgstr ""
"Der geographische Datentyp unterstützt Geometrien, ausgenommen sind jedoch "
"Kuven, TINS und POLYHEDRALSURFACEs. Daten vom geometrischen Datentyp, welche "
"eine SRID von 4326 aufweisen, werden implizit in den geographischen Datentyp "
"umgewandelt. Sie können Daten auch entsprechend der EWKT- und EWKB-"
"Konvention einfügen."

#. Tag: para
#: using_postgis_dataman.xml:274
#, no-c-format
msgid ""
"POINT: Creating a table with 2D point geography when srid is not specified "
"defaults to 4326 WGS 84 long lat:"
msgstr ""
"POINT: Erstellung einer 2D-Punkttabelle mit dem geographischen Datentyp. "
"Wenn die SRID nicht festgelegt ist, wird 4326 WGS 84 Länge und Breite "
"angenommen:"

#. Tag: programlisting
#: using_postgis_dataman.xml:275
#, no-c-format
msgid "CREATE TABLE ptgeogwgs(gid serial PRIMARY KEY, geog geography(POINT) );"
msgstr ""
"CREATE TABLE ptgeogwgs(gid serial PRIMARY KEY, geog geography(POINT) );"

#. Tag: para
#: using_postgis_dataman.xml:276
#, no-c-format
msgid "POINT: Creating a table with 2D point geography in NAD83 longlat:"
msgstr ""
"POINT: Erstellung einer Tabelle mit 2D-Punkten als geographischen Datentyp "
"in NAD83 Länge und Breite:"

#. Tag: programlisting
#: using_postgis_dataman.xml:277
#, no-c-format
msgid ""
"CREATE TABLE ptgeognad83(gid serial PRIMARY KEY, geog "
"geography(POINT,4269) );"
msgstr ""
"CREATE TABLE ptgeognad83(gid serial PRIMARY KEY, geog "
"geography(POINT,4269) );"

#. Tag: para
#: using_postgis_dataman.xml:278
#, no-c-format
msgid "Creating a table with z coordinate point and explicitly specifying srid"
msgstr ""
"Erstellung einer Punkttabelle mit Z-Koordinaten und explizit angegebener SRID"

#. Tag: programlisting
#: using_postgis_dataman.xml:279
#, no-c-format
msgid ""
"CREATE TABLE ptzgeogwgs84(gid serial PRIMARY KEY, geog "
"geography(POINTZ,4326) );"
msgstr ""
"CREATE TABLE ptzgeogwgs84(gid serial PRIMARY KEY, geog "
"geography(POINTZ,4326) );"

#. Tag: para
#: using_postgis_dataman.xml:282
#, no-c-format
msgid "LINESTRING"
msgstr "LINESTRING"

#. Tag: programlisting
#: using_postgis_dataman.xml:283
#, no-c-format
msgid ""
"CREATE TABLE lgeog(gid serial PRIMARY KEY, geog geography(LINESTRING) );"
msgstr ""
"CREATE TABLE lgeog(gid serial PRIMARY KEY, geog geography(LINESTRING) );"

#. Tag: para
#: using_postgis_dataman.xml:286
#, no-c-format
msgid "POLYGON"
msgstr "POLYGON"

#. Tag: programlisting
#: using_postgis_dataman.xml:287
#, no-c-format
msgid ""
"--polygon NAD 1927 long lat\n"
"CREATE TABLE lgeognad27(gid serial PRIMARY KEY, geog "
"geography(POLYGON,4267) );"
msgstr ""
"-- Polygon in NAD 1927 Länge und Breite\n"
"CREATE TABLE lgeognad27(gid serial PRIMARY KEY, geog "
"geography(POLYGON,4267) );"

#. Tag: para
#: using_postgis_dataman.xml:290
#, no-c-format
msgid "MULTIPOINT"
msgstr "MULTIPOINT"

#. Tag: para
#: using_postgis_dataman.xml:293
#, no-c-format
msgid "MULTILINESTRING"
msgstr "MULTILINESTRING"

#. Tag: para
#: using_postgis_dataman.xml:296
#, no-c-format
msgid "MULTIPOLYGON"
msgstr "MULTIPOLYGON"

#. Tag: para
#: using_postgis_dataman.xml:299
#, no-c-format
msgid "GEOMETRYCOLLECTION"
msgstr "GEOMETRYCOLLECTION"

#. Tag: para
#: using_postgis_dataman.xml:303
#, no-c-format
msgid ""
"The geography fields get registered in the <varname>geography_columns</"
"varname> system view."
msgstr ""
"Die Attribute des geographischen Datentyps werden in dem System View "
"<varname>geography_columns</varname> registriert."

#. Tag: para
#: using_postgis_dataman.xml:305
#, no-c-format
msgid ""
"Now, check the \"geography_columns\" view and see that your table is listed."
msgstr ""
"Nun überprüfen Sie bitte ob Ihre Tabelle in der gespeicherten Abfrage "
"\"geography_columns\" aufscheint."

#. Tag: para
#: using_postgis_dataman.xml:307
#, no-c-format
msgid ""
"You can create a new table with a GEOGRAPHY column using the CREATE TABLE "
"syntax."
msgstr ""
"Sie können eine neue Tabelle mit einer geographischen Datentypspalte mit der "
"Syntax von CREATE TABLE erstellen."

#. Tag: programlisting
#: using_postgis_dataman.xml:310
#, no-c-format
msgid ""
"CREATE TABLE global_points (\n"
"    id SERIAL PRIMARY KEY,\n"
"    name VARCHAR(64),\n"
"    location GEOGRAPHY(POINT,4326)\n"
"  );"
msgstr ""
"CREATE TABLE global_points (\n"
"    id SERIAL PRIMARY KEY,\n"
"    name VARCHAR(64),\n"
"    location GEOGRAPHY(POINT,4326)\n"
"  );"

#. Tag: para
#: using_postgis_dataman.xml:313
#, no-c-format
msgid ""
"Note that the location column has type GEOGRAPHY and that geography type "
"supports two optional modifiers: a type modifier that restricts the kind of "
"shapes and dimensions allowed in the column; an SRID modifier that restricts "
"the coordinate reference identifier to a particular number."
msgstr ""
"Beachten Sie bitte, dass die Spalte \"location\" den geographischen Datentyp "
"verwendet und dieser zwei optionale Modifikatoren unterstützt: Einen "
"Typmodifikator, der die geometrische Form und die Dimension der "
"Geometriespalte festlegt; ein Modifikator für SRID, der den Identifikator "
"für das Koordinatenreferenzsystem auf eine bestimmte Zahl einschränkt."

#. Tag: para
#: using_postgis_dataman.xml:314
#, no-c-format
msgid ""
"Allowable values for the type modifier are: POINT, LINESTRING, POLYGON, "
"MULTIPOINT, MULTILINESTRING, MULTIPOLYGON. The modifier also supports "
"dimensionality restrictions through suffixes: Z, M and ZM. So, for example a "
"modifier of 'LINESTRINGM' would only allow line strings with three "
"dimensions in, and would treat the third dimension as a measure. Similarly, "
"'POINTZM' would expect four dimensional data."
msgstr ""
"Für den Typmodifikator sind folgende Werte erlaubt: POINT, LINESTRING, "
"POLYGON, MULTIPOINT, MULTILINESTRING, MULTIPOLYGON. Der Modifikator "
"unterstützt auch Einschränkungen der Dimensionalität durch Nachsilben: Z, M "
"und ZM. So erlaubt zum Beispiel ein Modifikator mit dem Wert 'LINESTRINGM' "
"nur die Eingabe von Linienzügen mit drei Dimensionen, wobei die dritte "
"Dimension als Kilometrierung/measure behandelt wird. Ebenso verlangt "
"'POINTZM' die Eingabe von vierdimensionalen Daten."

#. Tag: para
#: using_postgis_dataman.xml:316
#, no-c-format
msgid ""
"If you do not specify an SRID, the SRID will default to 4326 WGS 84 long/lat "
"will be used, and all calculations will proceed using WGS84."
msgstr ""
"Wenn Sie keine SRID angeben, dann wird standardmäßig die SRID 4326 WGS84 "
"Länge/Breite verwendet und alle Berechnungen in WGS84 ausgeführt."

#. Tag: para
#: using_postgis_dataman.xml:317
#, no-c-format
msgid ""
"Once you have created your table, you can see it in the GEOGRAPHY_COLUMNS "
"table:"
msgstr ""
"Sobald Sie Ihre Tabelle erstellt haben, können Sie diese in der Tabelle "
"\"geography_columns\" sehen:"

#. Tag: programlisting
#: using_postgis_dataman.xml:318
#, no-c-format
msgid ""
"-- See the contents of the metadata view\n"
"SELECT * FROM geography_columns;"
msgstr ""
"-- Metadaten abfragen\n"
"SELECT * FROM geography_columns;"

#. Tag: para
#: using_postgis_dataman.xml:320
#, no-c-format
msgid ""
"You can insert data into the table the same as you would if it was using a "
"GEOMETRY column:"
msgstr ""
"Sie können Daten auf dieselbe Art und Weise in die Tabelle einfügen wie Sie "
"dies bei einer Geometriespalte tun würden:"

#. Tag: programlisting
#: using_postgis_dataman.xml:322
#, no-c-format
msgid ""
"-- Add some data into the test table\n"
"INSERT INTO global_points (name, location) VALUES ('Town', 'SRID=4326;"
"POINT(-110 30)');\n"
"INSERT INTO global_points (name, location) VALUES ('Forest', 'SRID=4326;"
"POINT(-109 29)');\n"
"INSERT INTO global_points (name, location) VALUES ('London', 'SRID=4326;"
"POINT(0 49)');"
msgstr ""
"-- Ein paar Daten in die Testtabelle einfügen\n"
"INSERT INTO global_points (name, location) VALUES ('Town', 'SRID=4326;"
"POINT(-110 30)');\n"
"INSERT INTO global_points (name, location) VALUES ('Forest', 'SRID=4326;"
"POINT(-109 29)');\n"
"INSERT INTO global_points (name, location) VALUES ('London', 'SRID=4326;"
"POINT(0 49)');"

#. Tag: para
#: using_postgis_dataman.xml:324
#, no-c-format
msgid ""
"Creating an index works the same as GEOMETRY. PostGIS will note that the "
"column type is GEOGRAPHY and create an appropriate sphere-based index "
"instead of the usual planar index used for GEOMETRY."
msgstr ""
"Die Erstellung eines Index funktioniert gleich wie beim Datentyp GEOMETRY. "
"PostGIS erkennt, dass es sich um den Datentyp GEOGRAPHY handelt und erzeugt "
"einen entsprechenden, auf einer Kugeloberfläche basierenden Index anstelle "
"des üblichen planaren Index, der für den Datentyp GEOMETRY verwendet wird."

#. Tag: programlisting
#: using_postgis_dataman.xml:327
#, no-c-format
msgid ""
"-- Index the test table with a spherical index\n"
"  CREATE INDEX global_points_gix ON global_points USING GIST ( location );"
msgstr ""
"-- Einen sphärischen Index auf die Testtabelle legen\n"
"  CREATE INDEX global_points_gix ON global_points USING GIST ( location );"

#. Tag: para
#: using_postgis_dataman.xml:330
#, no-c-format
msgid ""
"Query and measurement functions use units of meters. So distance parameters "
"should be expressed in meters, and return values should be expected in "
"meters (or square meters for areas)."
msgstr ""
"Anfrage und Messfunktionen verwenden die Einheit Meter. Daher sollten "
"Entfernungsparameter in Metern ausgedrückt werden und die Rückgabewerte "
"sollten ebenfalls in Meter (oder Quadratmeter für Flächen) erwartet werden."

#. Tag: programlisting
#: using_postgis_dataman.xml:332
#, no-c-format
msgid ""
"-- Show a distance query and note, London is outside the 1000km tolerance\n"
"  SELECT name FROM global_points WHERE ST_DWithin(location, 'SRID=4326;"
"POINT(-110 29)'::geography, 1000000);"
msgstr ""
"-- Eine Distanzabfrage; Beachten Sie bitte, dass London ausserhalb der "
"1000km Toleranz liegt\n"
"  SELECT name FROM global_points WHERE ST_DWithin(location, 'SRID=4326;"
"POINT(-110 29)'::geography, 1000000);"

#. Tag: para
#: using_postgis_dataman.xml:335
#, no-c-format
msgid ""
"You can see the power of GEOGRAPHY in action by calculating how close a "
"plane flying from Seattle to London (LINESTRING(-122.33 47.606, 0.0 51.5)) "
"comes to Reykjavik (POINT(-21.96 64.15))."
msgstr ""
"Sie können die Mächtigkeit von GEOGRAPHY erfahren, indem Sie berechnen, wie "
"nahe ein Flugzeug, das von Seattle nach London (LINESTRING(-122.33 47.606, "
"0.0 51.5)) fliegt, an Reykjavik (POINT(-21.96 64.15)) vorbeikommt."

#. Tag: programlisting
#: using_postgis_dataman.xml:337
#, no-c-format
msgid ""
"-- Distance calculation using GEOGRAPHY (122.2km)\n"
"  SELECT ST_Distance('LINESTRING(-122.33 47.606, 0.0 51.5)'::geography, "
"'POINT(-21.96 64.15)'::geography);"
msgstr ""
"-- Die Entfernung mittels GEOGRAPHY ausrechnen (122.2km)\n"
"  SELECT ST_Distance('LINESTRING(-122.33 47.606, 0.0 51.5)'::geography, "
"'POINT(-21.96 64.15)':: geography);"

#. Tag: programlisting
#: using_postgis_dataman.xml:340
#, no-c-format
msgid ""
"-- Distance calculation using GEOMETRY (13.3 \"degrees\")\n"
"  SELECT ST_Distance('LINESTRING(-122.33 47.606, 0.0 51.5)'::geometry, "
"'POINT(-21.96 64.15)'::geometry);"
msgstr ""
"-- Die Entfernung mittels GEOMETRIE ausrechnen (13.3 \"degrees\")\n"
"  SELECT ST_Distance('LINESTRING(-122.33 47.606, 0.0 51.5)'::geometry, "
"'POINT(-21.96 64.15)':: geometry);"

#. Tag: para
#: using_postgis_dataman.xml:343
#, no-c-format
msgid ""
"Testing different lon/lat projects. Any long lat spatial reference system "
"listed in <varname>spatial_ref_sys</varname> table is allowed."
msgstr ""
"Ausprobieren von verschiedenen Projektionen  in Länge/Breie. Es ist jedes "
"Koordinatenreferenzsystem in Länge und Breite zulässig, das in der Tabelle "
"<varname>spatial_ref_sys</varname> aufgeführt ist."

#. Tag: programlisting
#: using_postgis_dataman.xml:345
#, no-c-format
msgid ""
"-- NAD 83 lon/lat\n"
"SELECT 'SRID=4269;POINT(-123 34)'::geography;\n"
"                    geography\n"
"----------------------------------------------------\n"
" 0101000020AD1000000000000000C05EC00000000000004140\n"
"(1 row)"
msgstr ""
"-- NAD 83 in Länge und Breite\n"
"SELECT 'SRID=4269;POINT(-123 34)'::geography;\n"
"                    geography\n"
"----------------------------------------------------\n"
" 0101000020AD1000000000000000C05EC00000000000004140\n"
"(1 row)"

#. Tag: programlisting
#: using_postgis_dataman.xml:347
#, no-c-format
msgid ""
"-- NAD27 lon/lat\n"
"SELECT 'SRID=4267;POINT(-123 34)'::geography;\n"
"\n"
"                    geography\n"
"----------------------------------------------------\n"
" 0101000020AB1000000000000000C05EC00000000000004140\n"
"(1 row)"
msgstr ""
"-- NAD27  in Länge und Breite\n"
"SELECT 'SRID=4267;POINT(-123 34)'::geography;\n"
"\n"
"                    geography\n"
"----------------------------------------------------\n"
" 0101000020AB1000000000000000C05EC00000000000004140\n"
"(1 row)"

#. Tag: programlisting
#: using_postgis_dataman.xml:349
#, no-c-format
msgid ""
"-- NAD83 UTM zone meters, yields error since its a meter based projection\n"
"SELECT 'SRID=26910;POINT(-123 34)'::geography;\n"
"\n"
"ERROR:  Only lon/lat coordinate systems are supported in geography.\n"
"LINE 1: SELECT 'SRID=26910;POINT(-123 34)'::geography;"
msgstr ""
"-- NAD83 UTM Zone in Meter, resultiert in einem Fehler, da metrische "
"Projektion\n"
"SELECT 'SRID=26910;POINT(-123 34)'::geography;\n"
"\n"
"ERROR:  Nur Koordinatensysteme in Länge und Breite werden vom geographischen "
"Datentyp unterstützt.\n"
"LINE 1: SELECT 'SRID=26910;POINT(-123 34)'::geography;"

#. Tag: para
#: using_postgis_dataman.xml:351
#, no-c-format
msgid ""
"The GEOGRAPHY type calculates the true shortest distance over the sphere "
"between Reykjavik and the great circle flight path between Seattle and "
"London."
msgstr ""
"Mit dem Datentyp GEOGRAPHY wird die wahre, kürzeste Entfernung auf der "
"Kugeloberfläche zwischen Reykjavik und der Flugstrecke entlang des "
"Großkreises von Seattle nach London errechnet."

#. Tag: para
#: using_postgis_dataman.xml:353
#, no-c-format
msgid ""
"<ulink url=\"http://gc.kls2.com/cgi-bin/gc?PATH=SEA-LHR\">Great Circle "
"mapper</ulink> The GEOMETRY type calculates a meaningless cartesian distance "
"between Reykjavik and the straight line path from Seattle to London plotted "
"on a flat map of the world. The nominal units of the result might be called "
"\"degrees\", but the result doesn't correspond to any true angular "
"difference between the points, so even calling them \"degrees\" is "
"inaccurate."
msgstr ""
"<ulink url=\"http://gc.kls2.com/cgi-bin/gc?PATH=SEA-LHR\">Great Circle "
"mapper</ulink> Beim geometrischen Datentyp wird die Entfernung "
"sinnloserweise in einem kartesischen Koordinatensystem zwischen Reykjavik "
"und einer Geraden von Seattle nach London errechnet und auf einer ebenen "
"Weltkarte angezeigt. Dem Namen nach mag das Ergebnis in der Einheit \"Grad\" "
"angegeben sein, da es aber in keiner Weise irgendeinem wahren Winkel "
"zwischen den Punkten entspricht, ist sogar die Verwendung der Bezeichnung "
"\"Grad\" falsch."

#. Tag: title
#: using_postgis_dataman.xml:357
#, no-c-format
msgid "When to use Geography Data type over Geometry data type"
msgstr ""
"Wann sollte man den geographischen Datentyp dem geometrischen Datentyp "
"vorziehen"

#. Tag: para
#: using_postgis_dataman.xml:358
#, no-c-format
msgid ""
"The geography type allows you to store data in longitude/latitude "
"coordinates, but at a cost: there are fewer functions defined on GEOGRAPHY "
"than there are on GEOMETRY; those functions that are defined take more CPU "
"time to execute."
msgstr ""
"Der geographische Datentyp speichert die Koordinaten in Form von Länge und "
"Breite. Er hat allerdings den Nachteil, dass für den Datentyp GEOGRAPHY "
"weniger Funktionen zur Verfügung stehen,  als für den Datentyp GEOMETRY und "
"diese auch mehr CPU-Zeit beanspruchen."

#. Tag: para
#: using_postgis_dataman.xml:359
#, no-c-format
msgid ""
"The type you choose should be conditioned on the expected working area of "
"the application you are building. Will your data span the globe or a large "
"continental area, or is it local to a state, county or municipality?"
msgstr ""
"Welchen Datentyp Sie wählen, sollte aufgrund der zu erwartenden "
"Flächenausdehnung ihrer Anwendung festgelegt werden. Erstrecken sich Ihre "
"Daten über den gesamten Globus oder über eine große kontinentale Fläche, "
"oder sind sie auf einen Staat, ein Land oder eine Gemeinde beschränkt."

#. Tag: para
#: using_postgis_dataman.xml:361
#, no-c-format
msgid ""
"If your data is contained in a small area, you might find that choosing an "
"appropriate projection and using GEOMETRY is the best solution, in terms of "
"performance and functionality available."
msgstr ""
"Wenn sich Ihre Daten in einem kleinen Bereich befinden, werden Sie "
"vermutlich eine passende Projektion wählen und den geometrischen Datentyp "
"verwenden, da dies in Bezug auf die Rechenleistung und die verfügbare "
"Funktionalität die bessere Lösung ist."

#. Tag: para
#: using_postgis_dataman.xml:362
#, no-c-format
msgid ""
"If your data is global or covers a continental region, you may find that "
"GEOGRAPHY allows you to build a system without having to worry about "
"projection details. You store your data in longitude/latitude, and use the "
"functions that have been defined on GEOGRAPHY."
msgstr ""
"Wenn Ihre Daten global sind oder einen ganzen Kontinent bedecken, ermöglicht "
"der geographische Datentyp ein System aufzubauen, bei dem Sie sich nicht um "
"Projektionsdetails kümmern müssen. Sie speichern die Daten als Länge und "
"Breite und verwenden dann jene Funktionen, die für den geographischen "
"Datentyp definiert sind."

#. Tag: para
#: using_postgis_dataman.xml:364
#, no-c-format
msgid ""
"If you don't understand projections, and you don't want to learn about them, "
"and you're prepared to accept the limitations in functionality available in "
"GEOGRAPHY, then it might be easier for you to use GEOGRAPHY than GEOMETRY. "
"Simply load your data up as longitude/latitude and go from there."
msgstr ""
"Wenn Sie keine Ahnung von Projektionen haben, sich nicht näher damit "
"beschäftigen wollen und die Einschränkungen der verfügbaren Funktionalität "
"für den geographischen Datentyp in Kauf nehmen können, ist es vermutlich "
"einfacher für Sie, den geographischen anstatt des geometrischen Datentyps zu "
"verwenden."

#. Tag: para
#: using_postgis_dataman.xml:367
#, no-c-format
msgid ""
"Refer to <xref linkend=\"PostGIS_TypeFunctionMatrix\"/> for compare between "
"what is supported for Geography vs. Geometry. For a brief listing and "
"description of Geography functions, refer to <xref linkend="
"\"PostGIS_GeographyFunctions\"/>"
msgstr ""
"Für einen Vergleich, welche Funktionalität von Geography vs. Geometry "
"unterstützt wird, siehe <xref linkend=\"PostGIS_TypeFunctionMatrix\"/>. Für "
"eine kurze Liste mit der Beschreibung der geographischen Funktionen, siehe "
"<xref linkend=\"PostGIS_GeographyFunctions\"/>"

#. Tag: title
#: using_postgis_dataman.xml:373
#, no-c-format
msgid "Geography Advanced FAQ"
msgstr "Fortgeschrittene FAQ's zum geographischen Datentyp"

#. Tag: para
#: using_postgis_dataman.xml:377
#, no-c-format
msgid "Do you calculate on the sphere or the spheroid?"
msgstr ""
"Werden die Berechnungen auf einer Kugel oder auf einem Rotationsellipsoid "
"durchgeführt?"

#. Tag: para
#: using_postgis_dataman.xml:381
#, no-c-format
msgid ""
"By default, all distance and area calculations are done on the spheroid. You "
"should find that the results of calculations in local areas match up will "
"with local planar results in good local projections. Over larger areas, the "
"spheroidal calculations will be more accurate than any calculation done on a "
"projected plane."
msgstr ""
"Standardmäßig werden alle Entfernungs- und Flächenberechnungen auf dem "
"Referenzellipsoid ausgeführt. Das Ergebnis der Berechnung sollte in lokalen "
"Gebieten gut mit dem planaren Ergebnis zusammenpassen - eine gut gewählte "
"lokale Projektion vorausgesetzt. Bei größeren Gebieten ist die Berechnung "
"über das Referenzellipsoid genauer als eine Berechnung die auf der "
"projizierten Ebene ausgeführt wird."

#. Tag: para
#: using_postgis_dataman.xml:384
#, no-c-format
msgid ""
"All the geography functions have the option of using a sphere calculation, "
"by setting a final boolean parameter to 'FALSE'. This will somewhat speed up "
"calculations, particularly for cases where the geometries are very simple."
msgstr ""
"Alle geographischen Funktionen verfügen über eine Option um die Berechnung "
"auf einer Kugel durchzuführen. Dies erreicht man, indem der letzte boolesche "
"Eingabewert auf 'FALSE' gesetzt wird. Dies beschleunigt die Berechnung "
"einigermaßen, insbesondere wenn die Geometrie sehr einfach gestaltet ist."

#. Tag: para
#: using_postgis_dataman.xml:390
#, no-c-format
msgid "What about the date-line and the poles?"
msgstr "Wie schaut das mit der Datumsgrenze und den Polen aus?"

#. Tag: para
#: using_postgis_dataman.xml:394
#, no-c-format
msgid ""
"All the calculations have no conception of date-line or poles, the "
"coordinates are spherical (longitude/latitude) so a shape that crosses the "
"dateline is, from a calculation point of view, no different from any other "
"shape."
msgstr ""
"Alle diese Berechnungen wissen weder über Datumsgrenzen noch über Pole "
"Bescheid. Da es sich um sphärische Koordinaten handelt (Länge und Breite), "
"unterscheidet sich eine Geometrie, die eine Datumsgrenze überschreitet vom "
"Gesichtspunkt der Berechnung her nicht von irgendeiner anderen Geometrie."

#. Tag: para
#: using_postgis_dataman.xml:402
#, no-c-format
msgid "What is the longest arc you can process?"
msgstr "Wie lang kann ein Bogen sein, damit er noch verarbeitet werden kann?"

#. Tag: para
#: using_postgis_dataman.xml:406
#, no-c-format
msgid ""
"We use great circle arcs as the \"interpolation line\" between two points. "
"That means any two points are actually joined up two ways, depending on "
"which direction you travel along the great circle. All our code assumes that "
"the points are joined by the *shorter* of the two paths along the great "
"circle. As a consequence, shapes that have arcs of more than 180 degrees "
"will not be correctly modelled."
msgstr ""
"Wir verwenden Großkreisbögen als \"Interpolationslinie\" zwischen zwei "
"Punkten. Das bedeutet, dass es für den Join zwischen zwei Punkten zwei "
"Möglichkeiten gibt, je nachdem, aus welcher Richtung man den Großkreis "
"überquert. Unser gesamter Code setzt voraus, dass die Punkte von der "
"\"kürzeren\" der beiden Strecken her durch den Großkreis verbunden werden. "
"Als Konsequenz wird eine Geometrie, welche Bögen von mehr als 180 Grad "
"aufweist nicht korrekt modelliert."

#. Tag: para
#: using_postgis_dataman.xml:413
#, no-c-format
msgid ""
"Why is it so slow to calculate the area of Europe / Russia / insert big "
"geographic region here ?"
msgstr ""
"Warum dauert es so lange, die Fläche von Europa / Russland / irgendeiner "
"anderen großen geographischen Region zu berechnen?"

#. Tag: para
#: using_postgis_dataman.xml:417
#, no-c-format
msgid ""
"Because the polygon is so darned huge! Big areas are bad for two reasons: "
"their bounds are huge, so the index tends to pull the feature no matter what "
"query you run; the number of vertices is huge, and tests (distance, "
"containment) have to traverse the vertex list at least once and sometimes N "
"times (with N being the number of vertices in the other candidate feature)."
msgstr ""
"Weil das Polygon so verdammt groß ist! Große Flächen sind aus zwei Gründen "
"schlecht: ihre Begrenzung ist riesig, wodurch der Index dazu tendiert, das "
"Geoobjekt herauszuholen, egal wie Sie die Anfrage ausführen; die Anzahl der "
"Knoten ist riesig, und Tests (wie ST_Distance, ST_Contains) müssen alle "
"Knoten zumindest einmal, manchmal sogar n-mal durchlaufen (wobei N die "
"Anzahl der Knoten im beteiligten Geoobjekt bezeichnet)."

#. Tag: para
#: using_postgis_dataman.xml:422
#, no-c-format
msgid ""
"As with GEOMETRY, we recommend that when you have very large polygons, but "
"are doing queries in small areas, you \"denormalize\" your geometric data "
"into smaller chunks so that the index can effectively subquery parts of the "
"object and so queries don't have to pull out the whole object every time. "
"Please consult <xref linkend=\"ST_Subdivide\"/> function documentation. Just "
"because you *can* store all of Europe in one polygon doesn't mean you "
"*should*."
msgstr ""
"Wenn es sich um sehr große Polygone handelt, die Abfragen aber nur in "
"kleinen Gebieten stattfinden, empfehlen wir wie beim geometrischen Datentyp, "
"dass Sie die Geometrie in kleinere Stücke \"denormalisieren\". Dadurch kann "
"der Index effiziente Unterabfragen auf Teile des Geoobjekts ausführen, da "
"eine Abfrage nicht jedesmal das gesamte Geoobjekt herausholen muss. "
"Konsultieren Sie dazu bitte die Dokumentation der Funktion<xref linkend="
"\"ST_Subdivide\"/>. Nur weil Sie ganz Europa in einem Polygon speichern "
"*können* heißt das nicht, dass Sie dies auch tun *sollten*."

#. Tag: title
#: using_postgis_dataman.xml:431
#, no-c-format
msgid "Using OpenGIS Standards"
msgstr "Verwendung von OGC-Standards"

#. Tag: para
#: using_postgis_dataman.xml:433
#, no-c-format
msgid ""
"The OpenGIS \"Simple Features Specification for SQL\" defines standard GIS "
"object types, the functions required to manipulate them, and a set of meta-"
"data tables. In order to ensure that meta-data remain consistent, operations "
"such as creating and removing a spatial column are carried out through "
"special procedures defined by OpenGIS."
msgstr ""
"Die OpenGIS \"Simple Features Specification for SQL\" standardisert die "
"Datentypen von Geoobjekten, die Funktionen die benötigt werden um diese zu "
"verarbeiten, sowie die Metadatentabellen. Um sicherzustellen, dass die "
"Metadaten konsistent bleiben, werden Vorgänge wie das Erstellen oder das "
"Löschen einer Geometriespalte, durch dafür eigens von OpenGIS festgelegten "
"Prozeduren ausgeführt."

#. Tag: para
#: using_postgis_dataman.xml:439
#, no-c-format
msgid ""
"There are two OpenGIS meta-data tables: <varname>SPATIAL_REF_SYS</varname> "
"and <varname>GEOMETRY_COLUMNS</varname>. The <varname>SPATIAL_REF_SYS</"
"varname> table holds the numeric IDs and textual descriptions of coordinate "
"systems used in the spatial database."
msgstr ""
"Es gibt zwei OpenGIS Metadatentabellen: <varname>SPATIAL_REF_SYS</varname> "
"und <varname>GEOMETRY_COLUMNS</varname>. Die <varname>SPATIAL_REF_SYS</"
"varname> Tabelle enthält die numerischen Identifikatoren und textlichen "
"Beschreibungen der in der Datenbank verwendeten Koordinatensysteme."

#. Tag: title
#: using_postgis_dataman.xml:446
#, no-c-format
msgid "The SPATIAL_REF_SYS Table and Spatial Reference Systems"
msgstr "Die SPATIAL_REF_SYS Tabelle und Koordinatenreferenzsysteme"

#. Tag: para
#: using_postgis_dataman.xml:448
#, no-c-format
msgid ""
"The spatial_ref_sys table is a PostGIS included and OGC compliant database "
"table that lists over 3000 known <ulink url=\"http://www.sharpgis.net/"
"post/2007/05/Spatial-references2c-coordinate-systems2c-projections2c-"
"datums2c-ellipsoids-e28093-confusing.aspx\">spatial reference systems</"
"ulink> and details needed to transform/reproject between them."
msgstr ""
"Die Tabelle \"spatial_ref_sys\" ist eine mit PostGIS kommende und OGC-"
"konforme Datenbanktabelle, die über 3000 bekannte <ulink url=\"http://www."
"sharpgis.net/post/2007/05/Spatial-references2c-coordinate-systems2c-"
"projections2c-datums2c-ellipsoids-e28093-confusing.aspx"
"\">Koordinatenreferenzsysteme</ulink> enthält, sowie Details zur "
"Koordinatentransformation zwischen diesen."

#. Tag: para
#: using_postgis_dataman.xml:452
#, no-c-format
msgid ""
"Although the PostGIS spatial_ref_sys table contains over 3000 of the more "
"commonly used spatial reference system definitions that can be handled by "
"the proj library, it does not contain all known to man and you can define "
"your own custom projection if you are familiar with proj4 constructs. Keep "
"in mind that most spatial reference systems are regional and have no meaning "
"when used outside of the bounds they were intended for."
msgstr ""
"Obwohl in der PostGIS Tabelle \"spatial_ref_sys\" über 3000 der "
"gebräuchlichsten Koordinatenreferenzsysteme definiert sind, die mit der "
"Bibliothek \"Proj4\" gehandhabt werden können, enthält sie nicht alle "
"bekannten Projektionen. Sie können auch ihre eigenen Projektionen in der "
"Tabelle definieren, falls Sie mit den Konstrukten von \"Proj4\" vertraut "
"sind. Sie sollten nicht außer Acht lassen, dass die meisten "
"Koordinatenreferenzsysteme regional sind und außerhalb des vorgesehenen "
"Bereichs keinen Sinn haben."

#. Tag: para
#: using_postgis_dataman.xml:454
#, no-c-format
msgid ""
"An excellent resource for finding spatial reference systems not defined in "
"the core set is <ulink url=\"http://spatialreference.org/\">http://"
"spatialreference.org/</ulink>"
msgstr ""
"Eine hervorragende Quelle zum Auffinden von Koordinatenreferenzsystemen, "
"welche nicht in der Grundmenge enthalten sind, ist <ulink url=\"http://"
"spatialreference.org/\">http://spatialreference.org/</ulink>"

#. Tag: para
#: using_postgis_dataman.xml:456
#, no-c-format
msgid ""
"Some of the more commonly used spatial reference systems are: <ulink url="
"\"http://spatialreference.org/ref/epsg/4326/\">4326 - WGS 84 Long Lat</"
"ulink>, <ulink url=\"http://spatialreference.org/ref/epsg/4269/\">4269 - NAD "
"83 Long Lat</ulink>, <ulink url=\"http://spatialreference.org/ref/epsg/3395/"
"\">3395 - WGS 84 World Mercator</ulink>, <ulink url=\"http://"
"spatialreference.org/ref/epsg/2163/\">2163 - US National Atlas Equal Area</"
"ulink>, Spatial reference systems for each NAD 83, WGS 84 UTM zone - UTM "
"zones are one of the most ideal for measurement, but only cover 6-degree "
"regions."
msgstr ""
"Einige der häufiger eingesetzten Koordinatenreferenzsysteme sind: <ulink url="
"\"http://spatialreference.org/ref/epsg/4326/\">4326 - WGS 84 Long Lat</"
"ulink>, <ulink url=\"http://spatialreference.org/ref/epsg/4269/\">4269 - NAD "
"83 Long Lat</ulink>, <ulink url=\"http://spatialreference.org/ref/epsg/3395/"
"\">3395 - WGS 84 World Mercator</ulink>, <ulink url=\"http://"
"spatialreference.org/ref/epsg/2163/\">2163 - US National Atlas Equal Area</"
"ulink>, Koordinatenreferenzsysteme für jede NAD 83, WGS 84 und UTM Zone - "
"UTM Zonen sind ideal für Messungen, decken aber nur 6 Grad breite, vertikale "
"Zonen ab."

#. Tag: para
#: using_postgis_dataman.xml:462
#, no-c-format
msgid ""
"Various US state plane spatial reference systems (meter or feet based) - "
"usually one or 2 exists per US state. Most of the meter ones are in the core "
"set, but many of the feet based ones or ESRI created ones you will need to "
"pull from <ulink url=\"http://spatialreference.org\">spatialreference.org</"
"ulink>."
msgstr ""
"Verschiedenste Koordinatenreferenzsysteme \"US State Plane\"  (auf Meter und "
"Fuß basierend) - üblicherweise 2 pro US Staat. Die meisten auf Meter "
"basierten befinden sich in der Grundmenge, aber viele der auf Fuß basierten, "
"oder von ESRI erzeugten müssen von <ulink url=\"http://spatialreference.org"
"\">spatialreference.org</ulink> heruntergeladen werden."

#. Tag: para
#: using_postgis_dataman.xml:466
#, no-c-format
msgid ""
"For details on determining which UTM zone to use for your area of interest, "
"check out the <ulink url=\"http://trac.osgeo.org/postgis/wiki/"
"UsersWikiplpgsqlfunctionsDistance\">utmzone PostGIS plpgsql helper function</"
"ulink>."
msgstr ""
"Genauere Angaben zur Ermittlung der UTM Zone für ein bestimmtes Gebiet "
"finden Sie unter <ulink url=\"http://trac.osgeo.org/postgis/wiki/"
"UsersWikiplpgsqlfunctionsDistance\">utmzone PostGIS plpgsql helper function</"
"ulink>."

#. Tag: para
#: using_postgis_dataman.xml:470
#, no-c-format
msgid "The <varname>SPATIAL_REF_SYS</varname> table definition is as follows:"
msgstr ""
"Die <varname>SPATIAL_REF_SYS</varname> Tabelle ist folgendermaßen definiert:"

#. Tag: programlisting
#: using_postgis_dataman.xml:473
#, no-c-format
msgid ""
"CREATE TABLE spatial_ref_sys (\n"
"  srid       INTEGER NOT NULL PRIMARY KEY,\n"
"  auth_name  VARCHAR(256),\n"
"  auth_srid  INTEGER,\n"
"  srtext     VARCHAR(2048),\n"
"  proj4text  VARCHAR(2048)\n"
")"
msgstr ""
"CREATE TABLE spatial_ref_sys (\n"
"  srid       INTEGER NOT NULL PRIMARY KEY,\n"
"  auth_name  VARCHAR(256),\n"
"  auth_srid  INTEGER,\n"
"  srtext     VARCHAR(2048),\n"
"  proj4text  VARCHAR(2048)\n"
")"

#. Tag: para
#: using_postgis_dataman.xml:475
#, no-c-format
msgid "The <varname>SPATIAL_REF_SYS</varname> columns are as follows:"
msgstr "Die <varname>SPATIAL_REF_SYS</varname> Spalten folgendermaßen:"

#. Tag: ulink
#: using_postgis_dataman.xml:480
#, no-c-format
msgid "<ulink url=\"http://en.wikipedia.org/wiki/SRID\">SRID</ulink>"
msgstr "<ulink url=\"http://en.wikipedia.org/wiki/SRID\">SRID</ulink>"

#. Tag: para
#: using_postgis_dataman.xml:483
#, no-c-format
msgid ""
"An integer value that uniquely identifies the Spatial Referencing System "
"(SRS) within the database."
msgstr ""
"Ein ganzzahliger Wert, der das Koordinatenreferenzsystem (SRS) innerhalb der "
"Datenbank eindeutig ausweist."

#. Tag: term
#: using_postgis_dataman.xml:489
#, no-c-format
msgid "AUTH_NAME"
msgstr "AUTH_NAME"

#. Tag: para
#: using_postgis_dataman.xml:492
#, no-c-format
msgid ""
"The name of the standard or standards body that is being cited for this "
"reference system. For example, \"EPSG\" would be a valid <varname>AUTH_NAME</"
"varname>."
msgstr ""
"Der Name des Standards oder der Normungsorganisation, unter dem dieses "
"Koordinatenreferenzsystem zitiert wird. Zum Beispiel ist \"EPSG\" ein "
"gültiger <varname>AUTH_NAME</varname>."

#. Tag: term
#: using_postgis_dataman.xml:499
#, no-c-format
msgid "AUTH_SRID"
msgstr "AUTH_SRID"

#. Tag: para
#: using_postgis_dataman.xml:502
#, no-c-format
msgid ""
"The ID of the Spatial Reference System as defined by the Authority cited in "
"the <varname>AUTH_NAME</varname>. In the case of EPSG, this is where the "
"EPSG projection code would go."
msgstr ""
"Die von der in <varname>AUTH_NAME</varname> zitierten Quelle festgelegte ID "
"des Koordinatenreferenzsystems. Im Falle von EPSG ist dies der EPSG "
"Projektionscode."

#. Tag: term
#: using_postgis_dataman.xml:509
#, no-c-format
msgid "SRTEXT"
msgstr "SRTEXT"

#. Tag: para
#: using_postgis_dataman.xml:512
#, no-c-format
msgid ""
"The Well-Known Text representation of the Spatial Reference System. An "
"example of a WKT SRS representation is:"
msgstr ""
"Die Well-Known-Text Darstellung des Koordinatenreferenzsystems. Ein Beispiel "
"dazu:"

#. Tag: programlisting
#: using_postgis_dataman.xml:515
#, no-c-format
msgid ""
"PROJCS[\"NAD83 / UTM Zone 10N\",\n"
"  GEOGCS[\"NAD83\",\n"
"        DATUM[\"North_American_Datum_1983\",\n"
"          SPHEROID[\"GRS 1980\",6378137,298.257222101]\n"
"        ],\n"
"        PRIMEM[\"Greenwich\",0],\n"
"        UNIT[\"degree\",0.0174532925199433]\n"
"  ],\n"
"  PROJECTION[\"Transverse_Mercator\"],\n"
"  PARAMETER[\"latitude_of_origin\",0],\n"
"  PARAMETER[\"central_meridian\",-123],\n"
"  PARAMETER[\"scale_factor\",0.9996],\n"
"  PARAMETER[\"false_easting\",500000],\n"
"  PARAMETER[\"false_northing\",0],\n"
"  UNIT[\"metre\",1]\n"
"]"
msgstr ""
"PROJCS[\"NAD83 / UTM Zone 10N\",\n"
"  GEOGCS[\"NAD83\",\n"
"        DATUM[\"North_American_Datum_1983\",\n"
"          SPHEROID[\"GRS 1980\",6378137,298.257222101]\n"
"        ],\n"
"        PRIMEM[\"Greenwich\",0],\n"
"        UNIT[\"degree\",0.0174532925199433]\n"
"  ],\n"
"  PROJECTION[\"Transverse_Mercator\"],\n"
"  PARAMETER[\"latitude_of_origin\",0],\n"
"  PARAMETER[\"central_meridian\",-123],\n"
"  PARAMETER[\"scale_factor\",0.9996],\n"
"  PARAMETER[\"false_easting\",500000],\n"
"  PARAMETER[\"false_northing\",0],\n"
"  UNIT[\"metre\",1]\n"
"]"

#. Tag: para
#: using_postgis_dataman.xml:517
#, no-c-format
msgid ""
"For a listing of EPSG projection codes and their corresponding WKT "
"representations, see <ulink url=\"http://www.opengeospatial.org/\">http://"
"www.opengeospatial.org/</ulink>. For a discussion of WKT in general, see the "
"OpenGIS \"Coordinate Transformation Services Implementation Specification\" "
"at <ulink url=\"http://www.opengeospatial.org/standards\">http://www."
"opengeospatial.org/standards</ulink>. For information on the European "
"Petroleum Survey Group (EPSG) and their database of spatial reference "
"systems, see <ulink url=\"http://www.epsg.org/\">http://www.epsg.org</ulink>."
msgstr ""
"Für eine Auflistung der EPSG Projektionscodes und deren entsprechende WKT "
"Darstellung siehe <ulink url=\"http://www.opengeospatial.org/\">http://www."
"opengeospatial.org/</ulink>. Eine allgemeine Erläuterung zu WKT finden Sie "
"in der OpenGIS \"Coordinate Transformation Services Implementation "
"Specification\" unter <ulink url=\"http://www.opengeospatial.org/standards"
"\">http://www.opengeospatial.org/standards</ulink>. Information zur European "
"Petroleum Survey Group (EPSG) und deren Datenbank über "
"Koordinatenreferenzsysteme finden Sie unter <ulink url=\"http://www.epsg.org/"
"\">http://www.epsg.org</ulink>."

#. Tag: term
#: using_postgis_dataman.xml:530
#, no-c-format
msgid "PROJ4TEXT"
msgstr "PROJ4TEXT"

#. Tag: para
#: using_postgis_dataman.xml:533
#, no-c-format
msgid ""
"PostGIS uses the Proj4 library to provide coordinate transformation "
"capabilities. The <varname>PROJ4TEXT</varname> column contains the Proj4 "
"coordinate definition string for a particular SRID. For example:"
msgstr ""
"PostGIS verwendet die Bibliothek \"Proj4\" zur Koordinatentransformation. "
"Die Spalte <varname>PROJ4TEXT</varname> enthält eine Proj4 Zeichenfolge mit "
"der Definition des Koordinatensystems für eine bestimmte SRID. Zum Beispiel:"

#. Tag: programlisting
#: using_postgis_dataman.xml:538
#, no-c-format
msgid "+proj=utm +zone=10 +ellps=clrk66 +datum=NAD27 +units=m"
msgstr "+proj=utm +zone=10 +ellps=clrk66 +datum=NAD27 +units=m"

#. Tag: para
#: using_postgis_dataman.xml:540
#, no-c-format
msgid ""
"For more information about, see the Proj4 web site at <ulink url=\"http://"
"trac.osgeo.org/proj/\">http://trac.osgeo.org/proj/</ulink>. The "
"<filename>spatial_ref_sys.sql</filename> file contains both <varname>SRTEXT</"
"varname> and <varname>PROJ4TEXT</varname> definitions for all EPSG "
"projections."
msgstr ""
"Weiterführende Information finden Sie auf der Proj4 Webseite unter <ulink "
"url=\"http://trac.osgeo.org/proj/\">http://trac.osgeo.org/proj/</ulink>. Die "
"Datei <filename>spatial_ref_sys.sql</filename> enthält sowohl "
"<varname>SRTEXT</varname> als auch <varname>PROJ4TEXT</varname> Definitionen "
"aller EPSG Projektionen."

#. Tag: title
#: using_postgis_dataman.xml:551
#, no-c-format
msgid "The GEOMETRY_COLUMNS VIEW"
msgstr "Der View GEOMETRY_COLUMNS"

#. Tag: para
#: using_postgis_dataman.xml:553
#, no-c-format
msgid ""
"<varname>GEOMETRY_COLUMNS</varname> is a view reading from database system "
"catalogs. Its structure is as follows:"
msgstr ""
"<varname>GEOMETRY_COLUMNS</varname> ist ein View der den Systemkatalog der "
"Datenbank ausliest. Er hat folgende Struktur:"

#. Tag: programlisting
#: using_postgis_dataman.xml:556
#, no-c-format
msgid "\\d geometry_columns"
msgstr "\\d geometry_columns"

#. Tag: screen
#: using_postgis_dataman.xml:557
#, no-c-format
msgid ""
"View \"public.geometry_columns\"\n"
"      Column       |          Type          | Modifiers\n"
"-------------------+------------------------+-----------\n"
" f_table_catalog   | character varying(256) |\n"
" f_table_schema    | character varying(256) |\n"
" f_table_name      | character varying(256) |\n"
" f_geometry_column | character varying(256) |\n"
" coord_dimension   | integer                |\n"
" srid              | integer                |\n"
" type              | character varying(30)  |"
msgstr ""
"View \"public.geometry_columns\"\n"
"      Column       |          Type          | Modifiers\n"
"-------------------+------------------------+-----------\n"
" f_table_catalog   | character varying(256) |\n"
" f_table_schema    | character varying(256) |\n"
" f_table_name      | character varying(256) |\n"
" f_geometry_column | character varying(256) |\n"
" coord_dimension   | integer                |\n"
" srid              | integer                |\n"
" type              | character varying(30)  |"

#. Tag: para
#: using_postgis_dataman.xml:559
#, no-c-format
msgid "The column meanings are:"
msgstr "Die Spalten bedeuten:"

#. Tag: term
#: using_postgis_dataman.xml:563
#, no-c-format
msgid "F_TABLE_CATALOG, F_TABLE_SCHEMA, F_TABLE_NAME"
msgstr "F_TABLE_CATALOG, F_TABLE_SCHEMA, F_TABLE_NAME"

#. Tag: para
#: using_postgis_dataman.xml:566
#, no-c-format
msgid ""
"The fully qualified name of the feature table containing the geometry "
"column. Note that the terms \"catalog\" and \"schema\" are Oracle-ish. There "
"is not PostgreSQL analogue of \"catalog\" so that column is left blank -- "
"for \"schema\" the PostgreSQL schema name is used (<varname>public</varname> "
"is the default)."
msgstr ""
"Der vollständige Name der Tabelle, welche die Geometriespalte enthält. Die "
"Bezeichnungen \"catalog\" und \"schema\" kommen von Oracle. Es gibt keine "
"Entsprechung in PostgreSQL für \"catalog\", weshalb diese Spalte leer bleibt "
"- für \"schema\" wird der Name des Schemas in PostgreSQL verwendet "
"(standardmäßig <varname>public</varname>)."

#. Tag: term
#: using_postgis_dataman.xml:575
#, no-c-format
msgid "F_GEOMETRY_COLUMN"
msgstr "F_GEOMETRY_COLUMN"

#. Tag: para
#: using_postgis_dataman.xml:578
#, no-c-format
msgid "The name of the geometry column in the feature table."
msgstr "Der Name der Geometriespalte in der Feature-Tabelle."

#. Tag: term
#: using_postgis_dataman.xml:583
#, no-c-format
msgid "COORD_DIMENSION"
msgstr "COORD_DIMENSION"

#. Tag: para
#: using_postgis_dataman.xml:586
#, no-c-format
msgid "The spatial dimension (2, 3 or 4 dimensional) of the column."
msgstr ""
"Die räumliche Dimension (2-, 3- oder 4-dimensional) der Geometriespalte."

#. Tag: term
#: using_postgis_dataman.xml:592
#, no-c-format
msgid "<term>SRID</term>"
msgstr "<term>SRID</term>"

#. Tag: para
#: using_postgis_dataman.xml:595
#, no-c-format
msgid ""
"The ID of the spatial reference system used for the coordinate geometry in "
"this table. It is a foreign key reference to the <varname>SPATIAL_REF_SYS</"
"varname>."
msgstr ""
"Der Identifikator des Koordinatenreferenzsystems, welches für die Geometrie "
"in dieser Tabelle verwendet wird. Dieser ist ein Fremdschlüssel, der sich "
"auf die Tabelle <varname>SPATIAL_REF_SYS</varname> bezieht."

#. Tag: term
#: using_postgis_dataman.xml:602
#, no-c-format
msgid "TYPE"
msgstr "TYPE"

#. Tag: para
#: using_postgis_dataman.xml:605
#, no-c-format
msgid ""
"The type of the spatial object. To restrict the spatial column to a single "
"type, use one of: POINT, LINESTRING, POLYGON, MULTIPOINT, MULTILINESTRING, "
"MULTIPOLYGON, GEOMETRYCOLLECTION or corresponding XYM versions POINTM, "
"LINESTRINGM, POLYGONM, MULTIPOINTM, MULTILINESTRINGM, MULTIPOLYGONM, "
"GEOMETRYCOLLECTIONM. For heterogeneous (mixed-type) collections, you can use "
"\"GEOMETRY\" as the type."
msgstr ""
"Der Datentyp des Geoobjekts. Um die räumliche Spalte auf einen einzelnen "
"Datentyp zu beschränken, benutzen Sie bitte: POINT, LINESTRING, POLYGON, "
"MULTIPOINT, MULTILINESTRING, MULTIPOLYGON, GEOMETRYCOLLECTION oder die "
"entsprechenden XYM Versionen POINTM, LINESTRINGM, POLYGONM, MULTIPOINTM, "
"MULTILINESTRINGM, MULTIPOLYGONM und GEOMETRYCOLLECTIONM. Für uneinheitliche "
"Kollektionen (gemischete Datentypen) können Sie den Datentyp \"GEOMETRY\" "
"verwenden."

#. Tag: para
#: using_postgis_dataman.xml:614
#, no-c-format
msgid ""
"This attribute is (probably) not part of the OpenGIS specification, but is "
"required for ensuring type homogeneity."
msgstr ""
"Dieses Attribut gehört (wahrscheinlich) nicht zur OpenGIS Spezifikation, "
"wird aber benötigt um homogene Datentypen zu gewährleisten."

#. Tag: title
#: using_postgis_dataman.xml:624
#, no-c-format
msgid "Creating a Spatial Table"
msgstr "Erstellung einer räumlichen Tabelle"

#. Tag: para
#: using_postgis_dataman.xml:626
#, no-c-format
msgid ""
"Creating a table with spatial data, can be done in one step. As shown in the "
"following example which creates a roads table with a 2D linestring geometry "
"column in WGS84 long lat"
msgstr ""
"Die Erzeugung einer Tabelle mit räumlichen Daten kann in einem Schritt "
"ausgeführt werden. Dies wird im folgenden Beispiel demonstriert, welches "
"eine Straßentabelle mit einer geometrischen Spalte für 2D Linienzüge in "
"WGS84 Länge/Breite erzeugt"

#. Tag: programlisting
#: using_postgis_dataman.xml:628
#, no-c-format
msgid ""
"CREATE TABLE ROADS (ID serial, ROAD_NAME text, geom "
"geometry(LINESTRING,4326) );"
msgstr ""
"CREATE TABLE ROADS (ID serial, ROAD_NAME text, geom "
"geometry(LINESTRING,4326) );"

#. Tag: para
#: using_postgis_dataman.xml:630
#, no-c-format
msgid ""
"We can add additional columns using standard ALTER TABLE command as we do in "
"this next example where we add a 3-D linestring."
msgstr ""
"Wir können zusätzliche Spalten hinzufügen, indem wir den normalen ALTER "
"TABLE Befehl verwenden. Wir zeigen dies im nächsten Beispiel, wo wir einen "
"3D-Linienzug hinzufügen."

#. Tag: programlisting
#: using_postgis_dataman.xml:631
#, no-c-format
msgid "ALTER TABLE roads ADD COLUMN geom2 geometry(LINESTRINGZ,4326);"
msgstr "ALTER TABLE roads ADD COLUMN geom2 geometry(LINESTRINGZ,4326);"

#. Tag: title
#: using_postgis_dataman.xml:635
#, no-c-format
msgid "Manually Registering Geometry Columns in geometry_columns"
msgstr "Geometrische Spalten in \"geometry_columns\" händisch registrieren"

#. Tag: para
#: using_postgis_dataman.xml:637
#, no-c-format
msgid ""
"Two of the cases where you may need this are the case of SQL Views and bulk "
"inserts. For bulk insert case, you can correct the registration in the "
"geometry_columns table by constraining the column or doing an alter table. "
"For views, you could expose using a CAST operation. Note, if your column is "
"typmod based, the creation process would register it correctly, so no need "
"to do anything. Also views that have no spatial function applied to the "
"geometry will register the same as the underlying table geometry column."
msgstr ""
"Zwei Fälle bei denen Sie dies benötigen könnten sind SQL-Views und "
"Masseninserts. Beim Fall von Masseninserts können Sie die Registrierung in "
"der Tabelle \"geometry_columns\" korrigieren, indem Sie auf die Spalte einen "
"CONSTRAINT setzen oder ein \"ALTER TABLE\" durchführen. Falls Ihre Spalte "
"Typmod basiert ist, geschieht die Registrierung beim Erstellungsprozess auf "
"korrekte Weise, so dass Sie hier nichts tun müssen. Auch Views, bei denen "
"keine räumliche Funktion auf die Geometrie angewendet wird, werden auf "
"gleiche Weise wie die Geometrie der zugrunde liegenden Tabelle registriert."

#. Tag: programlisting
#: using_postgis_dataman.xml:642
#, no-c-format
msgid ""
"-- Lets say you have a view created like this\n"
"CREATE VIEW public.vwmytablemercator AS\n"
"        SELECT gid, ST_Transform(geom, 3395) As geom, f_name\n"
"        FROM public.mytable;\n"
"\n"
"-- For it to register correctly\n"
"-- You need to cast the geometry\n"
"--\n"
"DROP VIEW public.vwmytablemercator;\n"
"CREATE VIEW  public.vwmytablemercator AS\n"
"        SELECT gid, ST_Transform(geom, 3395)::geometry(Geometry, 3395) As "
"geom, f_name\n"
"        FROM public.mytable;\n"
"\n"
"-- If you know the geometry type for sure is a 2D POLYGON then you could do\n"
"DROP VIEW public.vwmytablemercator;\n"
"CREATE VIEW  public.vwmytablemercator AS\n"
"        SELECT gid, ST_Transform(geom,3395)::geometry(Polygon, 3395) As "
"geom, f_name\n"
"        FROM public.mytable;"
msgstr ""
"-- Angenommen Sie erstellen folgenden View\n"
"CREATE VIEW  public.vwmytablemercator AS\n"
"        SELECT gid, ST_Transform(geom,3395) As geom, f_name\n"
"        FROM public.mytable;\n"
"\n"
"-- Für eine korrekte Registrierung\n"
"-- wird eine Typumwandlung der Geometrie benötigt\n"
"--\n"
"DROP VIEW public.vwmytablemercator;\n"
"CREATE VIEW  public.vwmytablemercator AS\n"
"        SELECT gid, ST_Transform(geom,3395)::geometry(Geometry, 3395) As "
"geom, f_name\n"
"        FROM public.mytable;\n"
"\n"
"-- Wenn Sie sicher sind, das es sich bei der Geometrie um ein 2D-Polygon "
"handelt, können Sie folgendes tun\n"
"DROP VIEW public.vwmytablemercator;\n"
"CREATE VIEW  public.vwmytablemercator AS\n"
"        SELECT gid, ST_Transform(geom,3395)::geometry(Polygon, 3395) As "
"geom, f_name\n"
"        FROM public.mytable;"

#. Tag: programlisting
#: using_postgis_dataman.xml:643
#, no-c-format
msgid ""
"--Lets say you created a derivative table by doing a bulk insert\n"
"SELECT poi.gid, poi.geom, citybounds.city_name\n"
"INTO myschema.my_special_pois\n"
"FROM poi INNER JOIN citybounds ON ST_Intersects(citybounds.geom, poi.geom);\n"
"\n"
"-- Create 2D index on new table\n"
"CREATE INDEX idx_myschema_myspecialpois_geom_gist\n"
"  ON myschema.my_special_pois USING gist(geom);\n"
"\n"
"-- If your points are 3D points or 3M points,\n"
"-- then you might want to create an nd index instead of a 2D index\n"
"CREATE INDEX my_special_pois_geom_gist_nd\n"
"        ON my_special_pois USING gist(geom gist_geometry_ops_nd);\n"
"\n"
"-- To manually register this new table's geometry column in "
"geometry_columns.\n"
"-- Note it will also change the underlying structure of the table to\n"
"-- to make the column typmod based.\n"
"SELECT populate_geometry_columns('myschema.my_special_pois'::regclass);\n"
"\n"
"-- If you are using PostGIS 2.0 and for whatever reason, you\n"
"-- you need the constraint based definition behavior\n"
"-- (such as case of inherited tables where all children do not have the same "
"type and srid)\n"
"-- set optional use_typmod argument to false\n"
"SELECT populate_geometry_columns('myschema.my_special_pois'::regclass, "
"false);"
msgstr ""
"-- Angenommen Sie haben eine abgeleitete Tabelle über ein Masseninsert "
"erzeugt\n"
"SELECT poi.gid, poi.geom, citybounds.city_name\n"
"INTO myschema.my_special_pois\n"
"FROM poi INNER JOIN citybounds ON ST_Intersects(citybounds.geom, poi.geom);\n"
"\n"
"-- Einen 2D Index auf die neue Tabelle legen\n"
"CREATE INDEX idx_myschema_myspecialpois_geom_gist\n"
"  ON myschema.my_special_pois USING gist(geom);\n"
"\n"
"-- Falls Ihre Punkte 3D-Punkte oder 3M-Punkte sind,\n"
"-- können Sie einen ND-Index anstatt eines 2D-Indexes erstellen\n"
"CREATE INDEX my_special_pois_geom_gist_nd\n"
"        ON my_special_pois USING gist(geom gist_geometry_ops_nd);\n"
"\n"
"-- Um die Geometriespalte der neuen Tabelle in geometry_columns händisch zu "
"registrieren.\n"
"-- Beachten Sie bitte, dass dies auch die zugrundeliegende Struktur der "
"Tabelle ändert,\n"
"-- um die Spalte Typmod basiert zu machen.\n"
"SELECT populate_geometry_columns('myschema.my_special_pois'::regclass);\n"
"\n"
"-- Wenn Sie PostGIS 2.0 verwenden und aus welchem Grund auch immer\n"
"-- das alte Verhalten mit auf CONSTRAINTs basierender Definition benötigen\n"
"-- (wie im Fall von vererbten Tabellen bei denen nicht alle Kindtabellen "
"denselben Datentyp und dieselbe SRID aufweisen),\n"
"-- setzen Sie das optionale Argument \"use_typmod\" auf FALSE\n"
"SELECT populate_geometry_columns('myschema.my_special_pois'::regclass, "
"false);"

#. Tag: para
#: using_postgis_dataman.xml:645
#, no-c-format
msgid ""
"Although the old-constraint based method is still supported, a constraint-"
"based geometry column used directly in a view, will not register correctly "
"in geometry_columns, as will a typmod one. In this example we define a "
"column using typmod and another using constraints."
msgstr ""
"Obwohl die alte auf CONSTRAINTs basierte Methode immer noch unterstützt "
"wird, wird eine auf Constraints basierende Geometriespalte, die direkt in "
"einem View verwendet wird, nicht korrekt in geometry_columns registriert. "
"Eine Typmod basierte wird korrekt registriert. Im folgenden Beispiel "
"definieren wir eine Spalte mit Typmod und eine andere mit Constraints."

#. Tag: programlisting
#: using_postgis_dataman.xml:648
#, no-c-format
msgid ""
"CREATE TABLE pois_ny(gid SERIAL PRIMARY KEY, poi_name text, cat text, geom "
"geometry(POINT,4326));\n"
"SELECT AddGeometryColumn('pois_ny', 'geom_2160', 2160, 'POINT', 2, false);"
msgstr ""
"CREATE TABLE pois_ny(gid SERIAL PRIMARY KEY, poi_name text, cat text, geom "
"geometry(POINT,4326));\n"
"SELECT AddGeometryColumn('pois_ny', 'geom_2160', 2160, 'POINT', 2, false);"

#. Tag: para
#: using_postgis_dataman.xml:649
#, no-c-format
msgid "If we run in psql"
msgstr "In psql:"

#. Tag: programlisting
#: using_postgis_dataman.xml:650
#, no-c-format
msgid "\\d pois_ny;"
msgstr "\\d pois_ny;"

#. Tag: para
#: using_postgis_dataman.xml:651
#, no-c-format
msgid ""
"We observe they are defined differently -- one is typmod, one is constraint"
msgstr ""
"Wir sehen, das diese Spalten unterschiedlich definiert sind -- eine mittels "
"Typmodifizierer, eine nutzt einen Constraint"

#. Tag: screen
#: using_postgis_dataman.xml:652
#, no-c-format
msgid ""
"Table \"public.pois_ny\"\n"
"  Column   |         Type          |                       Modifiers\n"
"\n"
"-----------+-----------------------"
"+------------------------------------------------------\n"
" gid       | integer               | not null default "
"nextval('pois_ny_gid_seq'::regclass)\n"
" poi_name  | text                  |\n"
" cat       | character varying(20) |\n"
" geom      | geometry(Point,4326)  |\n"
" geom_2160 | geometry              |\n"
"Indexes:\n"
"    \"pois_ny_pkey\" PRIMARY KEY, btree (gid)\n"
"Check constraints:\n"
"    \"enforce_dims_geom_2160\" CHECK (st_ndims(geom_2160) = 2)\n"
"    \"enforce_geotype_geom_2160\" CHECK (geometrytype(geom_2160) = 'POINT'::"
"text\n"
"        OR geom_2160 IS NULL)\n"
"    \"enforce_srid_geom_2160\" CHECK (st_srid(geom_2160) = 2160)"
msgstr ""
"Table \"public.pois_ny\"\n"
"  Column   |         Type          |                       Modifiers\n"
"\n"
"-----------+-----------------------"
"+------------------------------------------------------\n"
" gid       | integer               | not null default "
"nextval('pois_ny_gid_seq'::regclass)\n"
" poi_name  | text                  |\n"
" cat       | character varying(20) |\n"
" geom      | geometry(Point,4326)  |\n"
" geom_2160 | geometry              |\n"
"Indexes:\n"
"    \"pois_ny_pkey\" PRIMARY KEY, btree (gid)\n"
"Check constraints:\n"
"    \"enforce_dims_geom_2160\" CHECK (st_ndims(geom_2160) = 2)\n"
"    \"enforce_geotype_geom_2160\" CHECK (geometrytype(geom_2160) = 'POINT'::"
"text\n"
"        OR geom_2160 IS NULL)\n"
"    \"enforce_srid_geom_2160\" CHECK (st_srid(geom_2160) = 2160)"

#. Tag: para
#: using_postgis_dataman.xml:653
#, no-c-format
msgid "In geometry_columns, they both register correctly"
msgstr "Beide registrieren sich korrekt in \"geometry_columns\""

#. Tag: programlisting
#: using_postgis_dataman.xml:654
#, no-c-format
msgid ""
"SELECT f_table_name, f_geometry_column, srid, type\n"
"        FROM geometry_columns\n"
"        WHERE f_table_name = 'pois_ny';"
msgstr ""
"SELECT f_table_name, f_geometry_column, srid, type\n"
"        FROM geometry_columns\n"
"        WHERE f_table_name = 'pois_ny';"

#. Tag: screen
#: using_postgis_dataman.xml:655
#, no-c-format
msgid ""
"f_table_name | f_geometry_column | srid | type\n"
"-------------+-------------------+------+-------\n"
"pois_ny      | geom              | 4326 | POINT\n"
"pois_ny      | geom_2160         | 2160 | POINT"
msgstr ""
"f_table_name | f_geometry_column | srid | type\n"
"-------------+-------------------+------+-------\n"
"pois_ny      | geom              | 4326 | POINT\n"
"pois_ny      | geom_2160         | 2160 | POINT"

#. Tag: para
#: using_postgis_dataman.xml:656
#, no-c-format
msgid "However -- if we were to create a view like this"
msgstr "Jedoch -- wenn wir einen View auf die folgende Weise erstellen"

#. Tag: programlisting
#: using_postgis_dataman.xml:657
#, no-c-format
msgid ""
"CREATE VIEW vw_pois_ny_parks AS\n"
"SELECT *\n"
"  FROM pois_ny\n"
"  WHERE cat='park';\n"
"\n"
"SELECT f_table_name, f_geometry_column, srid, type\n"
"        FROM geometry_columns\n"
"        WHERE f_table_name = 'vw_pois_ny_parks';"
msgstr ""
"CREATE VIEW vw_pois_ny_parks AS\n"
"SELECT *\n"
"  FROM pois_ny\n"
"  WHERE cat='park';\n"
"\n"
"SELECT f_table_name, f_geometry_column, srid, type\n"
"        FROM geometry_columns\n"
"        WHERE f_table_name = 'vw_pois_ny_parks';"

#. Tag: para
#: using_postgis_dataman.xml:658
#, no-c-format
msgid ""
"The typmod based geom view column registers correctly, but the constraint "
"based one does not."
msgstr ""
"Die Typmod basierte geometrische Spalte eines View registriert sich korrekt, "
"die auf Constraint basierende nicht."

#. Tag: screen
#: using_postgis_dataman.xml:660
#, no-c-format
msgid ""
"f_table_name   | f_geometry_column | srid |   type\n"
"------------------+-------------------+------+----------\n"
" vw_pois_ny_parks | geom              | 4326 | POINT\n"
" vw_pois_ny_parks | geom_2160         |    0 | GEOMETRY"
msgstr ""
"f_table_name   | f_geometry_column | srid |   type\n"
"------------------+-------------------+------+----------\n"
" vw_pois_ny_parks | geom              | 4326 | POINT\n"
" vw_pois_ny_parks | geom_2160         |    0 | GEOMETRY"

#. Tag: para
#: using_postgis_dataman.xml:662
#, no-c-format
msgid ""
"This may change in future versions of PostGIS, but for now To force the "
"constraint based view column to register correctly, we need to do this:"
msgstr ""
"Dies kann sich bei zukünftigen Versionen von PostGIS ändern, vorerst müssen "
"Sie aber folgendes ausführen, um die auf Constraint basierende Spalte eines "
"View korrekt zu registrieren:"

#. Tag: programlisting
#: using_postgis_dataman.xml:664
#, no-c-format
msgid ""
"DROP VIEW vw_pois_ny_parks;\n"
"CREATE VIEW vw_pois_ny_parks AS\n"
"SELECT gid, poi_name, cat,\n"
"  geom,\n"
"  geom_2160::geometry(POINT,2160) As geom_2160\n"
"  FROM pois_ny\n"
"  WHERE cat = 'park';\n"
"SELECT f_table_name, f_geometry_column, srid, type\n"
"        FROM geometry_columns\n"
"        WHERE f_table_name = 'vw_pois_ny_parks';"
msgstr ""
"DROP VIEW vw_pois_ny_parks;\n"
"CREATE VIEW vw_pois_ny_parks AS\n"
"SELECT gid, poi_name, cat,\n"
"  geom,\n"
"  geom_2160::geometry(POINT,2160) As geom_2160\n"
"  FROM pois_ny\n"
"  WHERE cat = 'park';\n"
"SELECT f_table_name, f_geometry_column, srid, type\n"
"        FROM geometry_columns\n"
"        WHERE f_table_name = 'vw_pois_ny_parks';"

#. Tag: screen
#: using_postgis_dataman.xml:665
#, no-c-format
msgid ""
"f_table_name   | f_geometry_column | srid | type\n"
"------------------+-------------------+------+-------\n"
" vw_pois_ny_parks | geom              | 4326 | POINT\n"
" vw_pois_ny_parks | geom_2160         | 2160 | POINT"
msgstr ""
"f_table_name   | f_geometry_column | srid | type\n"
"------------------+-------------------+------+-------\n"
" vw_pois_ny_parks | geom              | 4326 | POINT\n"
" vw_pois_ny_parks | geom_2160         | 2160 | POINT"

#. Tag: title
#: using_postgis_dataman.xml:669
#, no-c-format
msgid "Ensuring OpenGIS compliancy of geometries"
msgstr "Wahrung der OGC-Konformität von Geometrien"

#. Tag: para
#: using_postgis_dataman.xml:671
#, no-c-format
msgid ""
"PostGIS is compliant with the Open Geospatial Consortium’s (OGC) OpenGIS "
"Specifications. As such, many PostGIS methods require, or more accurately, "
"assume that geometries that are operated on are both simple and valid. For "
"example, it does not make sense to calculate the area of a polygon that has "
"a hole defined outside of the polygon, or to construct a polygon from a non-"
"simple boundary line."
msgstr ""
"PostGIS ist mit den Open Geospatial Consortium (OGC) OpenGIS Spezifikationen "
"konform. Daher setzen viele PostGIS Methoden voraus, dass die Geometrien mit "
"denen sie rechnen sowohl \"Simple\" als auch \"Valid\" sind . Zum Beispiel "
"hat es keinen Sinn, die Fläche eines Polygons zu berechnen, das eine Insel "
"aufweist, die ausserhalb des Polygons festgelegt ist, oder ein Polygon aus "
"einer Begrenzungslinie zu konstruieren, welche nicht \"simple\" ist."

#. Tag: para
#: using_postgis_dataman.xml:678
#, no-c-format
msgid ""
"According to the OGC Specifications, a <emphasis>simple</emphasis> geometry "
"is one that has no anomalous geometric points, such as self intersection or "
"self tangency and primarily refers to 0 or 1-dimensional geometries (i.e. "
"<varname>[MULTI]POINT, [MULTI]LINESTRING</varname>). Geometry validity, on "
"the other hand, primarily refers to 2-dimensional geometries (i.e. "
"<varname>[MULTI]POLYGON)</varname> and defines the set of assertions that "
"characterizes a valid polygon. The description of each geometric class "
"includes specific conditions that further detail geometric simplicity and "
"validity."
msgstr ""
"Entsprechend der OGC Spezifikationen ist eine <emphasis>simple</emphasis> "
"Geometrie eine solche, die sich nicht selbst überschneidet oder berührt und "
"bezieht sich in erster Linie auf 0- und 1-dimensionale Geometrien "
"(insbesondere <varname>[MULTI]POINT, [MULTI]LINESTRING</varname>). "
"Andererseits bezieht sich die Validität einer Geometrie hauptsächlich auf 2-"
"dimensionale Geometrien (insbesondere <varname>[MULTI]POLYGON)</varname> und "
"definiert die Menge an Aussagen, welche ein valides/gültiges Polygon "
"auszeichnen. Die Beschreibung einer jeden geometrischen Klasse schließt "
"bestimmte Bedingungen mit ein, welche die Simplizität und Validität von "
"Geometrien näher beschreiben."

#. Tag: para
#: using_postgis_dataman.xml:688
#, no-c-format
msgid ""
"A <varname>POINT</varname> is inheritably <emphasis>simple</emphasis> as a 0-"
"dimensional geometry object."
msgstr ""
"Da ein <varname>POINT</varname> ein 0-dimensionales geometrisches Objekt "
"ist, ist er von vornherein <emphasis>simple</emphasis>."

#. Tag: para
#: using_postgis_dataman.xml:691
#, no-c-format
msgid ""
"<varname>MULTIPOINT</varname>s are <emphasis>simple</emphasis> if no two "
"coordinates (<varname>POINT</varname>s) are equal (have identical coordinate "
"values)."
msgstr ""
"<varname>MULTIPOINT</varname>s sind <emphasis>simple</emphasis>, wenn sich "
"keine zwei Koordinaten (<varname>POINT</varname>s) decken (keine identischen "
"Koordinatenpaare aufweisen)."

#. Tag: para
#: using_postgis_dataman.xml:695
#, no-c-format
msgid ""
"A <varname>LINESTRING</varname> is <emphasis>simple</emphasis> if it does "
"not pass through the same <varname>POINT</varname> twice (except for the "
"endpoints, in which case it is referred to as a linear ring and additionally "
"considered closed)."
msgstr ""
"Ein <varname>LINESTRING</varname> ist <emphasis>simple</emphasis>, wenn er "
"nicht zweimal durch denselben <varname>POINT</varname> geht (ausgenommen bei "
"Endpunkten, wo dieser als linearer Ring benannt wird und zusätzlich als "
"geschlossen angesehen wird)."

#. Tag: emphasis
#: using_postgis_dataman.xml:710
#, no-c-format
msgid "<emphasis>(a)</emphasis>"
msgstr "<emphasis>(a)</emphasis>"

#. Tag: emphasis
#: using_postgis_dataman.xml:720
#, no-c-format
msgid "<emphasis>(b)</emphasis>"
msgstr "<emphasis>(b)</emphasis>"

#. Tag: emphasis
#: using_postgis_dataman.xml:732
#, no-c-format
msgid "<emphasis>(c)</emphasis>"
msgstr "<emphasis>(c)</emphasis>"

#. Tag: emphasis
#: using_postgis_dataman.xml:742
#, no-c-format
msgid "<emphasis>(d)</emphasis>"
msgstr "<emphasis>(d)</emphasis>"

#. Tag: para
#: using_postgis_dataman.xml:752
#, no-c-format
msgid ""
"<emphasis role=\"bold\">(a)</emphasis> and <emphasis role=\"bold\">(c)</"
"emphasis> are simple <varname>LINESTRING</varname>s, <emphasis role=\"bold"
"\">(b)</emphasis> and <emphasis role=\"bold\">(d)</emphasis> are not."
msgstr ""
"<emphasis role=\"bold\">(a)</emphasis> und <emphasis role=\"bold\">(c)</"
"emphasis> sind simple <varname>LINESTRING</varname>s, <emphasis role=\"bold"
"\">(b)</emphasis> und <emphasis role=\"bold\">(d)</emphasis> nicht."

#. Tag: para
#: using_postgis_dataman.xml:761
#, no-c-format
msgid ""
"A <varname>MULTILINESTRING</varname> is <emphasis>simple</emphasis> only if "
"all of its elements are simple and the only intersection between any two "
"elements occurs at <varname>POINT</varname>s that are on the boundaries of "
"both elements."
msgstr ""
"Ein <varname>MULTILINESTRING</varname> ist nur dann <emphasis>simple</"
"emphasis>, wenn alle seine Elemente \"simple\" sind und die einzigen "
"Überschneidungen zwischen zwei Elementen nur an jenen <varname>POINT</"
"varname>s auftreten, die an den Begrenzungen der beiden Elemente liegen."

#. Tag: emphasis
#: using_postgis_dataman.xml:776
#, no-c-format
msgid "<emphasis>(e)</emphasis>"
msgstr "<emphasis>(e)</emphasis>"

#. Tag: emphasis
#: using_postgis_dataman.xml:786
#, no-c-format
msgid "<emphasis>(f)</emphasis>"
msgstr "<emphasis>(f)</emphasis>"

#. Tag: emphasis
#: using_postgis_dataman.xml:796
#, no-c-format
msgid "<emphasis>(g)</emphasis>"
msgstr "<emphasis>(g)</emphasis>"

#. Tag: para
#: using_postgis_dataman.xml:806
#, no-c-format
msgid ""
"<emphasis role=\"bold\">(e)</emphasis> and <emphasis role=\"bold\">(f)</"
"emphasis> are simple <varname>MULTILINESTRING</varname>s, <emphasis role="
"\"bold\">(g)</emphasis> is not."
msgstr ""
"<emphasis role=\"bold\">(e)</emphasis> und <emphasis role=\"bold\">(f)</"
"emphasis> sind simple <varname>MULTILINESTRING</varname>s, <emphasis role="
"\"bold\">(g)</emphasis> nicht."

#. Tag: para
#: using_postgis_dataman.xml:815
#, no-c-format
msgid ""
"By definition, a <varname>POLYGON</varname> is always <emphasis>simple</"
"emphasis>. It is <emphasis>valid</emphasis> if no two rings in the boundary "
"(made up of an exterior ring and interior rings) cross. The boundary of a "
"<varname>POLYGON</varname> may intersect at a <varname>POINT</varname> but "
"only as a tangent (i.e. not on a line). A <varname>POLYGON</varname> may not "
"have cut lines or spikes and the interior rings must be contained entirely "
"within the exterior ring."
msgstr ""
"Definitionsgemäß ist ein <varname>POLYGON</varname> immer <emphasis>simple</"
"emphasis>. Es ist <emphasis>valid</emphasis>, wenn sich keine zwei Ringe an "
"der Begrenzung (bestehend aus einem äußeren Ring und inneren Ringen) "
"kreuzen. Die Begrenzung eines <varname>POLYGON</varname>s darf an einem "
"<varname>POINT</varname> schneiden, allerdings nur als Tangente "
"(insbesondere nicht an einer Linie). Ein <varname>POLYGON</varname> darf "
"keine Schnittlinien oder \"Spikes\" aufweisen und die inneren Ringe müssen "
"zur Gänze im äußeren Ring enthalten sein."

#. Tag: emphasis
#: using_postgis_dataman.xml:833
#, no-c-format
msgid "<emphasis>(h)</emphasis>"
msgstr "<emphasis>(h)</emphasis>"

#. Tag: emphasis
#: using_postgis_dataman.xml:843
#, no-c-format
msgid "<emphasis>(i)</emphasis>"
msgstr "<emphasis>(i)</emphasis>"

#. Tag: emphasis
#: using_postgis_dataman.xml:853
#, no-c-format
msgid "<emphasis>(j)</emphasis>"
msgstr "<emphasis>(j)</emphasis>"

#. Tag: emphasis
#: using_postgis_dataman.xml:865
#, no-c-format
msgid "<emphasis>(k)</emphasis>"
msgstr "<emphasis>(k)</emphasis>"

#. Tag: emphasis
#: using_postgis_dataman.xml:875
#, no-c-format
msgid "<emphasis>(l)</emphasis>"
msgstr "<emphasis>(l)</emphasis>"

#. Tag: emphasis
#: using_postgis_dataman.xml:885
#, no-c-format
msgid "<emphasis>(m)</emphasis>"
msgstr "<emphasis>(m)</emphasis>"

#. Tag: para
#: using_postgis_dataman.xml:894
#, no-c-format
msgid ""
"<emphasis role=\"bold\">(h)</emphasis> and <emphasis role=\"bold\">(i)</"
"emphasis> are valid <varname>POLYGON</varname>s, <emphasis role=\"bold\">(j-"
"m)</emphasis> cannot be represented as single <varname>POLYGON</varname>s, "
"but <emphasis role=\"bold\">(j)</emphasis> and <emphasis role=\"bold\">(m)</"
"emphasis> could be represented as a valid <varname>MULTIPOLYGON</varname>."
msgstr ""
"<emphasis role=\"bold\">(h)</emphasis> und <emphasis role=\"bold\">(i)</"
"emphasis> sind valide <varname>POLYGON</varname>e, <emphasis role=\"bold"
"\">(j-m)</emphasis> können nicht als einzelne <varname>POLYGON</varname>e "
"dargestellt werden, aber <emphasis role=\"bold\">(j)</emphasis> und "
"<emphasis role=\"bold\">(m)</emphasis> können als ein valides "
"<varname>MULTIPOLYGON</varname> dargestellt werden."

#. Tag: para
#: using_postgis_dataman.xml:906
#, no-c-format
msgid ""
"A <varname>MULTIPOLYGON</varname> is <emphasis>valid</emphasis> if and only "
"if all of its elements are valid and the interiors of no two elements "
"intersect. The boundaries of any two elements may touch, but only at a "
"finite number of <varname>POINT</varname>s."
msgstr ""
"Ein <varname>MULTIPOLYGON</varname> ist dann und nur dann <emphasis>valid</"
"emphasis>e, wenn alle seine Elemente valide sind und sich das Innere zweier "
"Elemente nicht überschneidet. Die Begrenzungen zweier Elemente können sich "
"berühren, allerdings nur an einer endlichen Anzahl von <varname>POINT</"
"varname>s."

#. Tag: emphasis
#: using_postgis_dataman.xml:921
#, no-c-format
msgid "<emphasis>(n)</emphasis>"
msgstr "<emphasis>(n)</emphasis>"

#. Tag: emphasis
#: using_postgis_dataman.xml:931
#, no-c-format
msgid "<emphasis>(o)</emphasis>"
msgstr "<emphasis>(o)</emphasis>"

#. Tag: emphasis
#: using_postgis_dataman.xml:941
#, no-c-format
msgid "<emphasis>(p)</emphasis>"
msgstr "<emphasis>(p)</emphasis>"

#. Tag: para
#: using_postgis_dataman.xml:950
#, no-c-format
msgid ""
"<emphasis role=\"bold\">(n)</emphasis> and <emphasis role=\"bold\">(o)</"
"emphasis> are not valid <varname>MULTIPOLYGON</varname>s. <emphasis role="
"\"bold\">(p)</emphasis>, however, is valid."
msgstr ""
"<emphasis role=\"bold\">(n)</emphasis> und <emphasis role=\"bold\">(o)</"
"emphasis> sind keine validen <varname>MULTIPOLYGON</varname>s. Hingegen ist "
"<emphasis role=\"bold\">(p)</emphasis> valid."

#. Tag: para
#: using_postgis_dataman.xml:959
#, no-c-format
msgid ""
"Most of the functions implemented by the GEOS library rely on the assumption "
"that your geometries are valid as specified by the OpenGIS Simple Feature "
"Specification. To check simplicity or validity of geometries you can use the "
"<link linkend=\"ST_IsSimple\">ST_IsSimple()</link> and <link linkend="
"\"ST_IsValid\">ST_IsValid()</link>"
msgstr ""
"Die meisten von der GEOS Bibliothek implementierten Funktionen beruhen auf "
"der Annahme, dass die verwendete Geometrie - entsprechend der OpenGIS Simple "
"Feature Spezifikation - valide ist. Um die Simplizität und Validität einer "
"Geometrie festzustellen, können Sie <link linkend=\"ST_IsSimple"
"\">ST_IsSimple()</link> und <link linkend=\"ST_IsValid\">ST_IsValid()</link> "
"verwenden."

#. Tag: programlisting
#: using_postgis_dataman.xml:965
#, no-c-format
msgid ""
"-- Typically, it doesn't make sense to check\n"
"-- for validity on linear features since it will always return TRUE.\n"
"-- But in this example, PostGIS extends the definition of the OGC IsValid\n"
"-- by returning false if a LineString has less than 2 *distinct* vertices.\n"
"gisdb=# SELECT\n"
"   ST_IsValid('LINESTRING(0 0, 1 1)'),\n"
"   ST_IsValid('LINESTRING(0 0, 0 0, 0 0)');\n"
"\n"
" st_isvalid | st_isvalid\n"
"------------+-----------\n"
"      t     |     f"
msgstr ""
"-- Üblicherweise hat es keinen Sinn lineare Geometrien\n"
"-- auf Validität zu überprüfen, da immer TRUE zurückgegeben wird.\n"
"-- Aber in diesem Beispiel erweitert PostGIS die OGC Definition von IsValid\n"
"-- indem es FALSE zurückgibt, wenn ein LineString weniger als 2 *eindeutige* "
"Stützpunkte aufweist.\n"
"gisdb=# SELECT\n"
"   ST_IsValid('LINESTRING(0 0, 1 1)'),\n"
"   ST_IsValid('LINESTRING(0 0, 0 0, 0 0)');\n"
"\n"
" st_isvalid | st_isvalid\n"
"------------+-----------\n"
"      t     |     f"

#. Tag: para
#: using_postgis_dataman.xml:967
#, no-c-format
msgid ""
"By default, PostGIS does not apply this validity check on geometry input, "
"because testing for validity needs lots of CPU time for complex geometries, "
"especially polygons. If you do not trust your data sources, you can manually "
"enforce such a check to your tables by adding a check constraint:"
msgstr ""
"Standardmäßig überprüft PostGIS eine Geometrieeingabe nicht auf Validität, "
"da Validitätstests von komplexen Geometrien, insbesondere Polygonen, viel "
"CPU Zeit beanspruchen. Fall Sie Ihren Datenquellen nicht    trauen, können "
"Sie eine Überprüfung Ihrer Tabellen durch eine \"Check Constraint\"/"
"Prüfbeschränkung erzwingen:"

#. Tag: programlisting
#: using_postgis_dataman.xml:973
#, no-c-format
msgid ""
"ALTER TABLE mytable\n"
"  ADD CONSTRAINT geometry_valid_check\n"
"        CHECK (ST_IsValid(the_geom));"
msgstr ""
"ALTER TABLE mytable\n"
"  ADD CONSTRAINT geometry_valid_check\n"
"        CHECK (ST_IsValid(the_geom));"

#. Tag: para
#: using_postgis_dataman.xml:975
#, no-c-format
msgid ""
"If you encounter any strange error messages such as \"GEOS Intersection() "
"threw an error!\" when calling PostGIS functions with valid input "
"geometries, you likely found an error in either PostGIS or one of the "
"libraries it uses, and you should contact the PostGIS developers. The same "
"is true if a PostGIS function returns an invalid geometry for valid input."
msgstr ""
"Falls Sie irgendwelche seltsamen Fehlermeldungen, wie \"GEOS Intersection() "
"threw an error!\" erhalten, obwohl sie eine PostGIS Funktion mit validen "
"Eingabegeometrien aufgerufen haben, ist es wahrscheinlich dass Sie einen "
"Fehler in PostGIS oder einer von PostGIS verwendeten Bibliothek gefunden "
"haben. In diesem Fall sollten Sie das PostGIS Entwicklerteam kontaktieren. "
"Dasselbe gilt, wenn eine PostGIS Funktion auf eine valide Eingabegeometrie "
"eine invalide Geometrie zurückgibt."

#. Tag: para
#: using_postgis_dataman.xml:983
#, no-c-format
msgid ""
"Strictly compliant OGC geometries cannot have Z or M values. The <link "
"linkend=\"ST_IsValid\">ST_IsValid()</link> function won't consider higher "
"dimensioned geometries invalid! Invocations of <link linkend="
"\"AddGeometryColumn\">AddGeometryColumn()</link> will add a constraint "
"checking geometry dimensions, so it is enough to specify 2 there."
msgstr ""
"Eine streng konforme OGC-Geometrie hat keine Z- oder M-Werte. Die Funktion "
"<link linkend=\"ST_IsValid\">ST_IsValid()</link> betrachtet höhere "
"geometrische Dimensionen nicht als invalide! Aufrufe von <link linkend="
"\"AddGeometryColumn\">AddGeometryColumn()</link> fügen einen Check-"
"Constraint für die geometrische Dimension hinzu, weshalb es hier ausreicht 2 "
"anzugeben."

#. Tag: title
#: using_postgis_dataman.xml:993
#, no-c-format
msgid "Dimensionally Extended 9 Intersection Model (DE-9IM)"
msgstr "DE-9IM-Matrix (DE-9IM)"

#. Tag: para
#: using_postgis_dataman.xml:995
#, no-c-format
msgid ""
"It is sometimes the case that the typical spatial predicates (<xref linkend="
"\"ST_Intersects\"/>, <xref linkend=\"ST_Contains\"/>, <xref linkend="
"\"ST_Crosses\"/>, <xref linkend=\"ST_Touches\"/>, ...) are insufficient in "
"and of themselves to adequately provide that desired spatial filter."
msgstr ""
"Manchmal kommt es vor, dass die typischen räumlichen Aussagen (<xref linkend="
"\"ST_Intersects\"/>, <xref linkend=\"ST_Contains\"/>, <xref linkend="
"\"ST_Crosses\"/>, <xref linkend=\"ST_Touches\"/>, ...) an sich nicht "
"ausreichen, um den verlangten räumlichen Filter auf geeignete Weise zu "
"liefern.  "

#. Tag: para
#: using_postgis_dataman.xml:1007
#, no-c-format
msgid ""
"For example, consider a linear dataset representing a road network. It may "
"be the task of a GIS analyst to identify all road segments that cross each "
"other, not at a point, but on a line, perhaps invalidating some business "
"rule. In this case, <xref linkend=\"ST_Crosses\"/> does not adequately "
"provide the necessary spatial filter since, for linear features, it returns "
"<varname>true</varname> only where they cross at a point."
msgstr ""
"Betrachten Sie zum Beispiel einen linearen Datensatz, der ein Straßennetz "
"darstellt. Es kann sein, dass ein GIS-Analyst die Aufgabe hat, alle "
"Straßenabschnitte herauszufinden, die sich gegenseitig nicht an einem Punkt "
"sondern entlang einer Linie kreuzen, da dies möglicherweise einer "
"Unternehmensvorschrift widerspricht. In diesem Fall liefert <xref linkend="
"\"ST_Crosses\"/> nicht den passenden räumlichen Filter, da bei linearen "
"Geoobjekten nur dann <varname>TRUE</varname> zurückgeben wird, wenn sie sich "
"an einem Punkt kreuzen."

#. Tag: para
#: using_postgis_dataman.xml:1014
#, no-c-format
msgid ""
"One two-step solution might be to first perform the actual intersection "
"(<xref linkend=\"ST_Intersection\"/>) of pairs of road segments that "
"spatially intersect (<xref linkend=\"ST_Intersects\"/>), and then compare "
"the intersection's <xref linkend=\"ST_GeometryType\"/> with "
"'<varname>LINESTRING</varname>' (properly dealing with cases that return "
"<varname>GEOMETRYCOLLECTION</varname>s of <varname>[MULTI]POINT</varname>s, "
"<varname>[MULTI]LINESTRING</varname>s, etc.)."
msgstr ""
"Eine zweistufige Lösung kann sein, dass man zuerst die eigentliche "
"Verschneidung (<xref linkend=\"ST_Intersection\"/>) von  "
"Straßenabschnittspaaren, die sich räumlich überschneiden (<xref linkend="
"\"ST_Intersects\"/>) ausführt und anschließend den <xref linkend="
"\"ST_GeometryType\"/> der Verschneidung mit '<varname>LINESTRING</varname>' "
"vergleicht (vermutlich muss man sich mit Fällen auseinandersetzen die "
"<varname>GEOMETRYCOLLECTION</varname>s von <varname>[MULTI]POINT</varname>s, "
"<varname>[MULTI]LINESTRING</varname>s, etc. zurückgeben)."

#. Tag: para
#: using_postgis_dataman.xml:1022
#, no-c-format
msgid "A more elegant / faster solution may indeed be desirable."
msgstr "Eine elegantere/schnellere Lösung wäre sicherlich wünschenswert."

#. Tag: para
#: using_postgis_dataman.xml:1036
#, no-c-format
msgid ""
"A second [theoretical] example may be that of a GIS analyst trying to locate "
"all wharfs or docks that intersect a lake's boundary on a line and where "
"only one end of the wharf is up on shore. In other words, where a wharf is "
"within, but not completely within a lake, intersecting the boundary of a "
"lake on a line, and where the wharf's endpoints are both completely within "
"and on the boundary of the lake. The analyst may need to use a combination "
"of spatial predicates to isolate the sought after features:"
msgstr ""
"Ein zweites (theoretisches) Beispiel wäre, dass ein GIS-Analyst versucht, "
"alle Anlegestellen oder Kais, welche die Begrenzung eines Sees entlang einer "
"Linie überschneiden und bei denen nur ein Ende der Anlegestelle an der Küste "
"liegt. Anders ausgedrückt, wo ein Kai nicht zur Gänze im See liegt, da er "
"den See entlang einer Linie schneidet und seine Endpunkte sowohl zur Gänze "
"in und auf der Begrenzung des Sees liegen. Dazu kann es nötig sein, dass der "
"Analyst eine Kombination von Aussagen ausführen muss, um die gesuchten "
"Geoobjekte herauszufiltern:"

#. Tag: para
#: using_postgis_dataman.xml:1047
#, no-c-format
msgid "(lake, wharf) = TRUE"
msgstr "(lake, wharf) = TRUE"

#. Tag: para
#: using_postgis_dataman.xml:1051
#, no-c-format
msgid "(lake, wharf) = FALSE"
msgstr "(lake, wharf) = FALSE"

#. Tag: para
#: using_postgis_dataman.xml:1055
#, no-c-format
msgid "(<xref linkend=\"ST_Intersection\"/>(wharf, lake)) = 'LINESTRING'"
msgstr "(<xref linkend=\"ST_Intersection\"/>(wharf, lake)) = 'LINESTRING'"

#. Tag: para
#: using_postgis_dataman.xml:1060
#, no-c-format
msgid ""
"(<xref linkend=\"ST_Multi\"/>(<xref linkend=\"ST_Intersection\"/>(<xref "
"linkend=\"ST_Boundary\"/>(wharf), <xref linkend=\"ST_Boundary\"/>(lake)))) = "
"1"
msgstr ""
"(<xref linkend=\"ST_Multi\"/>(<xref linkend=\"ST_Intersection\"/>(<xref "
"linkend=\"ST_Boundary\"/>(wharf), <xref linkend=\"ST_Boundary\"/>(lake)))) = "
"1"

#. Tag: para
#: using_postgis_dataman.xml:1063
#, no-c-format
msgid "... (needless to say, this could get quite complicated)"
msgstr ""
"... (überflüssig zu erwähnen, das dies ziemlich kompliziert werden kann)"

#. Tag: para
#: using_postgis_dataman.xml:1072
#, no-c-format
msgid ""
"So enters the Dimensionally Extended 9 Intersection Model, or DE-9IM for "
"short."
msgstr "Somit stürzen wir uns auf die DE-9IM-Matrix, oder kurz DE-9IM"

#. Tag: title
#: using_postgis_dataman.xml:1076
#, no-c-format
msgid "Theory"
msgstr "Theorie"

#. Tag: para
#: using_postgis_dataman.xml:1078
#, no-c-format
msgid ""
"According to the <ulink url=\"http://www.opengeospatial.org/standards/sfs"
"\">OpenGIS Simple Features Implementation Specification for SQL</ulink>, "
"\"the basic approach to comparing two geometries is to make pair-wise tests "
"of the intersections between the Interiors, Boundaries and Exteriors of the "
"two geometries and to classify the relationship between the two geometries "
"based on the entries in the resulting 'intersection' matrix.\""
msgstr ""
"Gemäß der <ulink url=\"http://www.opengeospatial.org/standards/sfs\">OpenGIS "
"Simple Features Implementation Specification for SQL</ulink>, ist der "
"grundlegende Ansatz für einen Lagevergleich von zwei geometrischen Objekten, "
"die paarweise Überprüfung der Verschneidung des Inneren, der Begrenzung und "
"des Äusseren der beiden geometrischen Objekte und der Einstufung der "
"Beziehung zwischen den beiden geometrischen Objekten an Hand der Einträge in "
"die resultierende 'Verschneidungs'-Matrix."

#. Tag: glossterm
#: using_postgis_dataman.xml:1089
#, no-c-format
msgid "<glossterm>Boundary</glossterm>"
msgstr "<glossterm>Boundary</glossterm>"

#. Tag: para
#: using_postgis_dataman.xml:1092
#, no-c-format
msgid ""
"The boundary of a geometry is the set of geometries of the next lower "
"dimension. For <varname>POINT</varname>s, which have a dimension of 0, the "
"boundary is the empty set. The boundary of a <varname>LINESTRING</varname> "
"are the two endpoints. For <varname>POLYGON</varname>s, the boundary is the "
"linework that make up the exterior and interior rings."
msgstr ""
"Die Begrenzung einer Geometrie ist die geometrische Grundmenge der nächst "
"kleineren Dimension. Bei <varname>POINT</varname>s, die die Dimension 0 "
"haben ist die Begrenzung die leere Menge. Die Begrenzung eines "
"<varname>LINESTRING</varname>s sind die zwei Endpunkte. Bei "
"<varname>POLYGON</varname>en entspricht die Begrenzung jenen Linien, die die "
"äußeren und inneren Ringe zusammensetzen."

#. Tag: glossterm
#: using_postgis_dataman.xml:1103
#, no-c-format
msgid "<glossterm>Interior</glossterm>"
msgstr "<glossterm>Interior</glossterm>"

#. Tag: para
#: using_postgis_dataman.xml:1106
#, no-c-format
msgid ""
"The interior of a geometry are those points of a geometry that are left when "
"the boundary is removed. For <varname>POINT</varname>s, the interior is the "
"<varname>POINT</varname> itself. The interior of a <varname>LINESTRING</"
"varname> are the set of real points between the endpoints. For "
"<varname>POLYGON</varname>s, the interior is the areal surface inside the "
"polygon."
msgstr ""
"Die Innenseite/interior einer Geometrie besteht aus jenen Punkten einer "
"Geometrie, die zurückbleiben, wenn die Außenbegrenzung/boundary entfernt "
"wird. Bei <varname>POINT</varname>s ist die Innenseite der <varname>POINT</"
"varname> selbst. Die Innenseite eines <varname>LINESTRING</varname>s ist die "
"Menge der echten Punkte zwischen den Endpunkten. Bei <varname>POLYGON</"
"varname>en entspricht die Innenseite der Fläche innerhalb des Polygons."

#. Tag: glossterm
#: using_postgis_dataman.xml:1117
#, no-c-format
msgid "<glossterm>Exterior</glossterm>"
msgstr "<glossterm>Exterior</glossterm>"

#. Tag: para
#: using_postgis_dataman.xml:1120
#, no-c-format
msgid ""
"The exterior of a geometry is the universe, an areal surface, not on the "
"interior or boundary of the geometry."
msgstr ""
"Die Außenseite/exterior einer Geometrie ist durch die Grundgesamtheit "
"gegeben. Das ist jene Fläche, die nicht auf der Innenseite/interior oder auf "
"der Begrenzung der Geometrie liegt."

#. Tag: para
#: using_postgis_dataman.xml:1127
#, no-c-format
msgid ""
"Given geometry <emphasis>a</emphasis>, where the <emphasis>I(a)</emphasis>, "
"<emphasis>B(a)</emphasis>, and <emphasis>E(a)</emphasis> are the "
"<emphasis>Interior</emphasis>, <emphasis>Boundary</emphasis>, and "
"<emphasis>Exterior</emphasis> of a, the mathematical representation of the "
"matrix is:"
msgstr ""
"Gegeben sei die Geometrie <emphasis>a</emphasis>, wobei <emphasis>I(a)</"
"emphasis>, <emphasis>B(a)</emphasis>, und <emphasis>E(a)</emphasis> das "
"<emphasis>Innere/Interior</emphasis>, die <emphasis>Begrenzung/Boundary</"
"emphasis> und das<emphasis>Äussere/Exterior</emphasis> von a sind; die "
"mathematische Formulierung der Matrix lautet:"

#. Tag: emphasis
#: using_postgis_dataman.xml:1139 using_postgis_dataman.xml:1149
#: using_postgis_dataman.xml:1233 using_postgis_dataman.xml:1246
#, no-c-format
msgid "<emphasis role=\"bold\">Interior</emphasis>"
msgstr "<emphasis role=\"bold\">Interior</emphasis>"

#. Tag: emphasis
#: using_postgis_dataman.xml:1141 using_postgis_dataman.xml:1155
#: using_postgis_dataman.xml:1236 using_postgis_dataman.xml:1269
#, no-c-format
msgid "<emphasis role=\"bold\">Boundary</emphasis>"
msgstr "<emphasis role=\"bold\">Boundary</emphasis>"

#. Tag: emphasis
#: using_postgis_dataman.xml:1143 using_postgis_dataman.xml:1161
#: using_postgis_dataman.xml:1239 using_postgis_dataman.xml:1292
#, no-c-format
msgid "<emphasis role=\"bold\">Exterior</emphasis>"
msgstr "<emphasis role=\"bold\">Exterior</emphasis>"

#. Tag: emphasis
#: using_postgis_dataman.xml:1150
#, no-c-format
msgid "dim( I(a) ∩ I(b) )"
msgstr "dim( I(a) ∩ I(b) )"

#. Tag: emphasis
#: using_postgis_dataman.xml:1151
#, no-c-format
msgid "dim( I(a) ∩ B(b) )"
msgstr "dim( I(a) ∩ B(b) )"

#. Tag: emphasis
#: using_postgis_dataman.xml:1152
#, no-c-format
msgid "dim( I(a) ∩ E(b) )"
msgstr "dim( I(a) ∩ E(b) )"

#. Tag: emphasis
#: using_postgis_dataman.xml:1156
#, no-c-format
msgid "dim( B(a) ∩ I(b) )"
msgstr "dim( B(a) ∩ I(b) )"

#. Tag: emphasis
#: using_postgis_dataman.xml:1157
#, no-c-format
msgid "dim( B(a) ∩ B(b) )"
msgstr "dim( B(a) ∩ B(b) )"

#. Tag: emphasis
#: using_postgis_dataman.xml:1158
#, no-c-format
msgid "dim( B(a) ∩ E(b) )"
msgstr "dim( B(a) ∩ E(b) )"

#. Tag: emphasis
#: using_postgis_dataman.xml:1162
#, no-c-format
msgid "dim( E(a) ∩ I(b) )"
msgstr "dim( E(a) ∩ I(b) )"

#. Tag: emphasis
#: using_postgis_dataman.xml:1163
#, no-c-format
msgid "dim( E(a) ∩ B(b) )"
msgstr "dim( E(a) ∩ B(b) )"

#. Tag: emphasis
#: using_postgis_dataman.xml:1164
#, no-c-format
msgid "dim( E(a) ∩ E(b) )"
msgstr "dim( E(a) ∩ E(b) )"

#. Tag: para
#: using_postgis_dataman.xml:1171
#, no-c-format
msgid ""
"Where <emphasis>dim(a)</emphasis> is the dimension of <emphasis>a</emphasis> "
"as specified by <xref linkend=\"ST_Dimension\"/> but has the domain of "
"<literal>{0,1,2,T,F,*}</literal>"
msgstr ""
"Wobei <emphasis>dim(a)</emphasis>, so wie von <xref linkend=\"ST_Dimension\"/"
"> festgelegt, die Dimension von <emphasis>a</emphasis> ist, aber zu der "
"Domäne von <literal>{0,1,2,T,F,*}</literal> gehört."

#. Tag: para
#: using_postgis_dataman.xml:1178
#, no-c-format
msgid "<literal>0</literal> =&gt; point"
msgstr "<literal>0</literal> =&gt; point"

#. Tag: para
#: using_postgis_dataman.xml:1182
#, no-c-format
msgid "<literal>1</literal> =&gt; line"
msgstr "<literal>1</literal> =&gt; line"

#. Tag: para
#: using_postgis_dataman.xml:1186
#, no-c-format
msgid "<literal>2</literal> =&gt; area"
msgstr "<literal>2</literal> =&gt; area"

#. Tag: para
#: using_postgis_dataman.xml:1190
#, no-c-format
msgid "<literal>T</literal> =&gt; <literal>{0,1,2}</literal>"
msgstr "<literal>T</literal> =&gt; <literal>{0,1,2}</literal>"

#. Tag: para
#: using_postgis_dataman.xml:1195
#, no-c-format
msgid "<literal>F</literal> =&gt; empty set"
msgstr "<literal>F</literal> =&gt; Leere Menge"

#. Tag: para
#: using_postgis_dataman.xml:1199
#, no-c-format
msgid "<literal>*</literal> =&gt; don't care"
msgstr "<literal>*</literal> =&gt; braucht nicht zu kümmern"

#. Tag: para
#: using_postgis_dataman.xml:1203
#, no-c-format
msgid "Visually, for two overlapping polygonal geometries, this looks like:"
msgstr ""
"Bildlich schaut dies für zwei überlappende Polygongeometrien folgendermaßen "
"aus:"

#. Tag: para
#: using_postgis_dataman.xml:1250 using_postgis_dataman.xml:1262
#: using_postgis_dataman.xml:1296 using_postgis_dataman.xml:1308
#, no-c-format
msgid "<emphasis>dim(...) = </emphasis><emphasis role=\"bold\">2</emphasis>"
msgstr "<emphasis>dim(...) = </emphasis><emphasis role=\"bold\">2</emphasis>"

#. Tag: para
#: using_postgis_dataman.xml:1256 using_postgis_dataman.xml:1273
#: using_postgis_dataman.xml:1285 using_postgis_dataman.xml:1302
#, no-c-format
msgid "<emphasis>dim(...) = </emphasis><emphasis role=\"bold\">1</emphasis>"
msgstr "<emphasis>dim(...) = </emphasis><emphasis role=\"bold\">1</emphasis>"

#. Tag: para
#: using_postgis_dataman.xml:1279
#, no-c-format
msgid "<emphasis>dim(...) = </emphasis><emphasis role=\"bold\">0</emphasis>"
msgstr "<emphasis>dim(...) = </emphasis><emphasis role=\"bold\">0</emphasis>"

#. Tag: para
#: using_postgis_dataman.xml:1320
#, no-c-format
msgid ""
"Read from left to right and from top to bottom, the dimensional matrix is "
"represented, '<emphasis role=\"bold\">212101212</emphasis>'."
msgstr ""
"Von links nach rechts und von oben nach unten gelesen wird die "
"Dimensionsmatrix durch '<emphasis role=\"bold\">212101212</emphasis>' "
"dargestellt."

#. Tag: para
#: using_postgis_dataman.xml:1323
#, no-c-format
msgid ""
"A relate matrix that would therefore represent our first example of two "
"lines that intersect on a line would be: '<emphasis role=\"bold\">1*1***1**</"
"emphasis>'"
msgstr ""
"Eine Beziehungsmatrix, welche das erste Beispiel von zwei Linien, die sich "
"auf einer Linie schneiden, abbildet, würde '<emphasis role=\"bold"
"\">102101FF2</emphasis>' entsprechen."

#. Tag: programlisting
#: using_postgis_dataman.xml:1327
#, no-c-format
msgid ""
"-- Identify road segments that cross on a line\n"
"SELECT a.id\n"
"FROM roads a, roads b\n"
"WHERE a.id != b.id\n"
"AND a.geom &amp;&amp; b.geom\n"
"AND ST_Relate(a.geom, b.geom, '1*1***1**');"
msgstr ""
"-- Identifizierung der Strassenabschnitte, die eine Linie kreuzen\n"
"SELECT a.id\n"
"FROM roads a, roads b\n"
"WHERE a.id != b.id\n"
"AND a.geom &amp;&amp; b.geom\n"
"AND ST_Relate(a.geom, b.geom, '1*1***1**');"

#. Tag: para
#: using_postgis_dataman.xml:1329
#, no-c-format
msgid ""
"A relate matrix that represents the second example of wharfs partly on the "
"lake's shoreline would be '<emphasis role=\"bold\">102101FF2</emphasis>'"
msgstr ""
"Eine Beziehungsmatrix, welche das zweite Beispiel mit den Kais, die "
"teilweise an der Uferlinie des Sees liegen, abbildet, würde '<emphasis role="
"\"bold\">102101FF2</emphasis>' entsprechen."

#. Tag: programlisting
#: using_postgis_dataman.xml:1333
#, no-c-format
msgid ""
"-- Identify wharfs partly on a lake's shoreline\n"
"SELECT a.lake_id, b.wharf_id\n"
"FROM lakes a, wharfs b\n"
"WHERE a.geom &amp;&amp; b.geom\n"
"AND ST_Relate(a.geom, b.geom, '102101FF2');"
msgstr ""
"-- Ermittlung von Dämmen, die teilweise an der Uferlinie eines Sees liegen\n"
"SELECT a.lake_id, b.wharf_id\n"
"FROM lakes a, wharfs b\n"
"WHERE a.geom &amp;&amp; b.geom\n"
"AND ST_Relate(a.geom, b.geom, '102101FF2');"

#. Tag: para
#: using_postgis_dataman.xml:1335
#, no-c-format
msgid "For more information or reading, see:"
msgstr "Für weiterführende Information siehe:"

#. Tag: para
#: using_postgis_dataman.xml:1339
#, no-c-format
msgid ""
"<ulink url=\"http://www.opengeospatial.org/standards/sfs\">OpenGIS Simple "
"Features Implementation Specification for SQL</ulink> (version 1.1, section "
"2.1.13.2)"
msgstr ""
"<ulink url=\"http://www.opengeospatial.org/standards/sfs\">OpenGIS Simple "
"Features Implementation Specification for SQL</ulink> (Version 1.1, "
"Abschnitt 2.1.13.2)"

#. Tag: ulink
#: using_postgis_dataman.xml:1344
#, no-c-format
msgid "Dimensionally Extended Nine-Intersection Model (DE-9IM)"
msgstr "DE-9IM-Matrix (DE-9IM)"

#. Tag: ulink
#: using_postgis_dataman.xml:1348
#, no-c-format
msgid "GeoTools: Point Set Theory and the DE-9IM Matrix"
msgstr "Geotools: Mengentheoretische Topologie und die DE-9IM-Matrix"

#. Tag: para
#: using_postgis_dataman.xml:1351
#, no-c-format
msgid "<emphasis>Encyclopedia of GIS</emphasis> By Hui Xiong"
msgstr "<emphasis>Encyclopedia of GIS</emphasis> By Hui Xiong"

#. Tag: title
#: using_postgis_dataman.xml:1361
#, no-c-format
msgid "Loading GIS (Vector) Data"
msgstr "GIS (Vektor) Daten laden"

#. Tag: para
#: using_postgis_dataman.xml:1363
#, no-c-format
msgid ""
"Once you have created a spatial table, you are ready to upload GIS data to "
"the database. Currently, there are two ways to get data into a PostGIS/"
"PostgreSQL database: using formatted SQL statements or using the Shape file "
"loader/dumper."
msgstr ""
"Sobald Sie eine räumliche Tabelle erstellt haben, können Sie GIS Daten in "
"die Datenbank laden. Zurzeit gibt es zwei Möglichkeiten, Daten in die "
"PostGIS/PostgreSQL Datenbank zu importieren: die Verwendung von formatierten "
"SQL-Anweisungen oder der Shapefile Loader/Dumper."

#. Tag: title
#: using_postgis_dataman.xml:1369
#, no-c-format
msgid "Loading Data Using SQL"
msgstr "Daten via SQL laden"

#. Tag: para
#: using_postgis_dataman.xml:1371
#, no-c-format
msgid ""
"If you can convert your data to a text representation, then using formatted "
"SQL might be the easiest way to get your data into PostGIS. As with Oracle "
"and other SQL databases, data can be bulk loaded by piping a large text file "
"full of SQL \"INSERT\" statements into the SQL terminal monitor."
msgstr ""
"Wenn Sie Ihre Daten in eine Textdarstellung konvertieren können, dann ist "
"möglicherweise die Verwendung von formatiertem SQL der leichteste Weg um die "
"Daten in PostGIS zu importieren. Wie bei Oracle und anderen Datenbanken, "
"können die Daten über Masseninserts geladen werden, indem eine große "
"Textdatei, in der sich zahlreiche SQL \"INSERT\" Anweisungen befinden, an "
"die SQL-Konsole weitergeleitet wird."

#. Tag: para
#: using_postgis_dataman.xml:1377
#, no-c-format
msgid ""
"A data upload file (<filename>roads.sql</filename> for example) might look "
"like this:"
msgstr ""
"Eine Importdatei (z.B. <filename>roads.sql</filename>) könnte folgendermaßen "
"aussehen:"

#. Tag: programlisting
#: using_postgis_dataman.xml:1380
#, no-c-format
msgid ""
"BEGIN;\n"
"INSERT INTO roads (road_id, roads_geom, road_name)\n"
"  VALUES (1,'LINESTRING(191232 243118,191108 243242)','Jeff Rd');\n"
"INSERT INTO roads (road_id, roads_geom, road_name)\n"
"  VALUES (2,'LINESTRING(189141 244158,189265 244817)','Geordie Rd');\n"
"INSERT INTO roads (road_id, roads_geom, road_name)\n"
"  VALUES (3,'LINESTRING(192783 228138,192612 229814)','Paul St');\n"
"INSERT INTO roads (road_id, roads_geom, road_name)\n"
"  VALUES (4,'LINESTRING(189412 252431,189631 259122)','Graeme Ave');\n"
"INSERT INTO roads (road_id, roads_geom, road_name)\n"
"  VALUES (5,'LINESTRING(190131 224148,190871 228134)','Phil Tce');\n"
"INSERT INTO roads (road_id, roads_geom, road_name)\n"
"  VALUES (6,'LINESTRING(198231 263418,198213 268322)','Dave Cres');\n"
"COMMIT;"
msgstr ""
"BEGIN;\n"
"INSERT INTO roads (road_id, roads_geom, road_name)\n"
"  VALUES (1,'LINESTRING(191232 243118,191108 243242)','Jeff Rd');\n"
"INSERT INTO roads (road_id, roads_geom, road_name)\n"
"  VALUES (2,'LINESTRING(189141 244158,189265 244817)','Geordie Rd');\n"
"INSERT INTO roads (road_id, roads_geom, road_name)\n"
"  VALUES (3,'LINESTRING(192783 228138,192612 229814)','Paul St');\n"
"INSERT INTO roads (road_id, roads_geom, road_name)\n"
"  VALUES (4,'LINESTRING(189412 252431,189631 259122)','Graeme Ave');\n"
"INSERT INTO roads (road_id, roads_geom, road_name)\n"
"  VALUES (5,'LINESTRING(190131 224148,190871 228134)','Phil Tce');\n"
"INSERT INTO roads (road_id, roads_geom, road_name)\n"
"  VALUES (6,'LINESTRING(198231 263418,198213 268322)','Dave Cres');\n"
"COMMIT;"

#. Tag: para
#: using_postgis_dataman.xml:1382
#, no-c-format
msgid ""
"The data file can be piped into PostgreSQL very easily using the \"psql\" "
"SQL terminal monitor:"
msgstr ""
"Diese Datei kann dann über die \"psql\" SQL-Konsole sehr leicht nach "
"PostgreSQL weitergeleitet werden:"

#. Tag: programlisting
#: using_postgis_dataman.xml:1385
#, no-c-format
msgid "psql -d [database] -f roads.sql"
msgstr "psql -d [database] -f roads.sql"

#. Tag: title
#: using_postgis_dataman.xml:1389
#, no-c-format
msgid "shp2pgsql: Using the ESRI Shapefile Loader"
msgstr "shp2pgsql: Verwendung des ESRI-Shapefile Laders"

#. Tag: para
#: using_postgis_dataman.xml:1391
#, no-c-format
msgid ""
"The <filename>shp2pgsql</filename> data loader converts ESRI Shape files "
"into SQL suitable for insertion into a PostGIS/PostgreSQL database either in "
"geometry or geography format. The loader has several operating modes "
"distinguished by command line flags:"
msgstr ""
"Der <filename>shp2pgsql</filename> Datenlader wandelt ESRI Shapefiles in "
"eine SQL-Datei um, die für das Einfügen in eine PostGIS/PostgreSQL Datenbank "
"mit der \"psql\"-Konsole, sowohl im Geometrie- als auch im Geographie-"
"Format, geeignet ist. Der Loader besitzt eine Reihe von Betriebsmodi, die "
"durch Flags auf der Befehlszeile ausgewählt werden:"

#. Tag: para
#: using_postgis_dataman.xml:1396
#, no-c-format
msgid ""
"In addition to the shp2pgsql command-line loader, there is an "
"<filename>shp2pgsql-gui</filename> graphical interface with most of the "
"options as the command-line loader, but may be easier to use for one-off non-"
"scripted loading or if you are new to PostGIS. It can also be configured as "
"a plugin to PgAdminIII."
msgstr ""
"Zusätzlich zu dem befehlszeilenorientierten Lader \"shp2pgsql\" gibt es auch "
"die graphische Schnittstelle <filename>shp2pgssql-gui</filename>, welche "
"fast ebensoviele Optionen wie der befehlszeilenorientierte Lader zur "
"Verfügung stellt. Für viele  Anwender, die mit der Befehlszeile nicht "
"versiert sind, oder mit PostGIS erst beginnen, ist die GUI möglicherweise "
"einfacher zu bedienen. Sie kann auch in PgAdminIII als Plugin konfiguriert "
"werden."

#. Tag: term
#: using_postgis_dataman.xml:1403
#, no-c-format
msgid "(c|a|d|p) These are mutually exclusive options:"
msgstr "(c|a|d|p) Dies sind sich gegenseitig ausschließende Optionen:"

#. Tag: term
#: using_postgis_dataman.xml:1408
#, no-c-format
msgid "<term>-c</term>"
msgstr "<term>-c</term>"

#. Tag: para
#: using_postgis_dataman.xml:1410
#, no-c-format
msgid ""
"Creates a new table and populates it from the shapefile. <emphasis>This is "
"the default mode.</emphasis>"
msgstr ""
"Erstellt eine neue Tabelle und füllt sie von einem Shapefile her. "
"<emphasis>Dies ist der Standardmodus</emphasis>."

#. Tag: term
#: using_postgis_dataman.xml:1418
#, no-c-format
msgid "<term>-a</term>"
msgstr "<term>-a</term>"

#. Tag: para
#: using_postgis_dataman.xml:1420
#, no-c-format
msgid ""
"Appends data from the Shape file into the database table. Note that to use "
"this option to load multiple files, the files must have the same attributes "
"and same data types."
msgstr ""
"Fügt Daten aus dem Shapefile zu der Datenbanktabelle hinzu. Beachten Sie "
"bitte, falls Sie diese Option verwenden um mehrere Dateien zu laden, dass "
"die Attribute und Datentypen in den Dateien übereinstimmen müssen."

#. Tag: term
#: using_postgis_dataman.xml:1429
#, no-c-format
msgid "<term>-d</term>"
msgstr "<term>-d</term>"

#. Tag: para
#: using_postgis_dataman.xml:1431
#, no-c-format
msgid ""
"Drops the database table before creating a new table with the data in the "
"Shape file."
msgstr ""
"Löscht die Datenbanktabelle, bevor eine neue Tabelle mit den Daten vom "
"Shapefile befüllt wird."

#. Tag: term
#: using_postgis_dataman.xml:1439
#, no-c-format
msgid "<term>-p</term>"
msgstr "<term>-p</term>"

#. Tag: para
#: using_postgis_dataman.xml:1441
#, no-c-format
msgid ""
"Only produces the table creation SQL code, without adding any actual data. "
"This can be used if you need to completely separate the table creation and "
"data loading steps."
msgstr ""
"Erzeugt nur den SQL-Code zur Erstellung der Tabelle, ohne irgendwelche Daten "
"hinzuzufügen. Kann verwendet werden, um die Erstellung und das Laden einer "
"Tabelle vollständig zu trennen."

#. Tag: term
#: using_postgis_dataman.xml:1454
#, no-c-format
msgid "<term>-?</term>"
msgstr "<term>-?</term>"

#. Tag: para
#: using_postgis_dataman.xml:1456
#, no-c-format
msgid "Display help screen."
msgstr "Zeigt die Hilfe an."

#. Tag: term
#: using_postgis_dataman.xml:1463
#, no-c-format
msgid "<term>-D</term>"
msgstr "<term>-D</term>"

#. Tag: para
#: using_postgis_dataman.xml:1465
#, no-c-format
msgid ""
"Use the PostgreSQL \"dump\" format for the output data. This can be combined "
"with -a, -c and -d. It is much faster to load than the default \"insert\" "
"SQL format. Use this for very large data sets."
msgstr ""
"Verwendung des PostgreSQL \"dump\" Formats für die Datenausgabe. Kann mit -"
"a, -c und -d kombiniert werden. Ist wesentlich schneller als das "
"standardmäßige SQL \"insert\" Format. Verwenden Sie diese Option wenn Sie "
"sehr große Datensätze haben."

#. Tag: term
#: using_postgis_dataman.xml:1474
#, fuzzy, no-c-format
msgid "-s [&lt;FROM_SRID&gt;:]&lt;SRID&gt;"
msgstr "-s [&lt;FROM_SRID%gt;:]&lt;SRID&gt;"

#. Tag: para
#: using_postgis_dataman.xml:1476
#, fuzzy, no-c-format
msgid ""
"Creates and populates the geometry tables with the specified SRID. "
"Optionally specifies that the input shapefile uses the given FROM_SRID, in "
"which case the geometries will be reprojected to the target SRID."
msgstr ""
"Erzeugt und befüllt die Geometrietabelle in einer bestimmten SRID. Optional "
"kann FROM_SRID für die Shapedatei angegeben werden, wodurch die Geometrie "
"von FROM_SRID in die Ziel-SRID projiziert wird. FROM_SRID und -D können "
"nicht gleichzeitig angegeben werden."

#. Tag: term
#: using_postgis_dataman.xml:1486
#, no-c-format
msgid "<term>-k</term>"
msgstr "<term>-k</term>"

#. Tag: para
#: using_postgis_dataman.xml:1488
#, no-c-format
msgid ""
"Keep identifiers' case (column, schema and attributes). Note that attributes "
"in Shapefile are all UPPERCASE."
msgstr ""
"Erhält die Groß- und Kleinschreibung (Spalte, Schema und Attribute). "
"Beachten Sie bitte, dass die Attributnamen in Shapedateien immer "
"Großbuchstaben haben."

#. Tag: term
#: using_postgis_dataman.xml:1496
#, no-c-format
msgid "<term>-i</term>"
msgstr "<term>-i</term>"

#. Tag: para
#: using_postgis_dataman.xml:1498
#, no-c-format
msgid ""
"Coerce all integers to standard 32-bit integers, do not create 64-bit "
"bigints, even if the DBF header signature appears to warrant it."
msgstr ""
"Wandeln Sie alle Ganzzahlen in standard 32-bit Integer um, erzeugen Sie "
"keine 64-bit BigInteger, auch nicht dann wenn der DBF-Header dies "
"unterstellt."

#. Tag: term
#: using_postgis_dataman.xml:1506
#, no-c-format
msgid "<term>-I</term>"
msgstr "<term>-I</term>"

#. Tag: para
#: using_postgis_dataman.xml:1508
#, no-c-format
msgid "Create a GiST index on the geometry column."
msgstr "Einen GIST Index auf die Geometriespalte anlegen."

#. Tag: term
#: using_postgis_dataman.xml:1515
#, no-c-format
msgid "<term>-m</term>"
msgstr "<term>-m</term>"

#. Tag: para
#: using_postgis_dataman.xml:1517
#, no-c-format
msgid ""
"-m <filename>a_file_name</filename> Specify a file containing a set of "
"mappings of (long) column names to 10 character DBF column names. The "
"content of the file is one or more lines of two names separated by white "
"space and no trailing or leading space. For example:"
msgstr ""
"-m <filename>a_file_name</filename> bestimmt eine Datei, in welcher die "
"Abbildungen der (langen) Spaltennamen in die 10 Zeichen langen DBF "
"Spaltennamen festgelegt sind. Der Inhalt der Datei besteht aus einer oder "
"mehreren Zeilen die jeweils zwei, durch Leerzeichen getrennte Namen "
"enthalten, aber weder vorne noch hinten mit Leerzeichen versehen werden "
"dürfen. Zum Beispiel:"

#. Tag: programlisting
#: using_postgis_dataman.xml:1522
#, no-c-format
msgid ""
"COLUMNNAME DBFFIELD1\n"
"AVERYLONGCOLUMNNAME DBFFIELD2"
msgstr ""
"COLUMNNAME DBFFIELD1\n"
"AVERYLONGCOLUMNNAME DBFFIELD2"

#. Tag: term
#: using_postgis_dataman.xml:1528
#, no-c-format
msgid "<term>-S</term>"
msgstr "<term>-S</term>"

#. Tag: para
#: using_postgis_dataman.xml:1530
#, no-c-format
msgid ""
"Generate simple geometries instead of MULTI geometries. Will only succeed if "
"all the geometries are actually single (I.E. a MULTIPOLYGON with a single "
"shell, or or a MULTIPOINT with a single vertex)."
msgstr ""
"Erzeugt eine Einzel- anstatt einer Mehrfachgeometrie. Ist nur "
"erfolgversprechend, wenn die Geometrie auch tatsächlich eine Einzelgeometrie "
"ist (insbesondere gilt das für ein Mehrfachpolygon/MULTIPOLYGON, dass nur "
"aus einer einzelnen Begrenzung besteht, oder für einen Mehrfachpunkt/"
"MULTIPOINT, der nur einen einzigen Knoten aufweist)."

#. Tag: term
#: using_postgis_dataman.xml:1539
#, no-c-format
msgid "-t &lt;dimensionality&gt;"
msgstr "-t &lt;dimensionality&gt;"

#. Tag: para
#: using_postgis_dataman.xml:1541
#, no-c-format
msgid ""
"Force the output geometry to have the specified dimensionality. Use the "
"following strings to indicate the dimensionality: 2D, 3DZ, 3DM, 4D."
msgstr ""
"Zwingt die Ausgabegeometrie eine bestimmte Dimension anzunehmen. Sie können "
"die folgenden Zeichenfolgen verwenden, um die Dimensionalität anzugeben: 2D, "
"3DZ, 3DM, 4D."

#. Tag: para
#: using_postgis_dataman.xml:1545
#, no-c-format
msgid ""
"If the input has fewer dimensions that specified, the output will have those "
"dimensions filled in with zeroes. If the input has more dimensions that "
"specified, the unwanted dimensions will be stripped."
msgstr ""
"Wenn die Eingabe weniger Dimensionen aufweist als angegeben, dann werden "
"diese Dimensionen bei der Ausgabe mit Nullen gefüllt. Wenn die Eingabe mehr "
"Dimensionen als angegeben aufweist werden diese abgestreift."

#. Tag: term
#: using_postgis_dataman.xml:1554
#, no-c-format
msgid "<term>-w</term>"
msgstr "<term>-w</term>"

#. Tag: para
#: using_postgis_dataman.xml:1556
#, no-c-format
msgid ""
"Output WKT format, instead of WKB. Note that this can introduce coordinate "
"drifts due to loss of precision."
msgstr ""
"Ausgabe im Format WKT anstatt WKB. Beachten Sie bitte, dass es hierbei zu "
"Koordinatenverschiebungen infolge von Genauigkeitsverlusten kommen kann."

#. Tag: term
#: using_postgis_dataman.xml:1564
#, no-c-format
msgid "<term>-e</term>"
msgstr "<term>-e</term>"

#. Tag: para
#: using_postgis_dataman.xml:1566
#, no-c-format
msgid ""
"Execute each statement on its own, without using a transaction. This allows "
"loading of the majority of good data when there are some bad geometries that "
"generate errors. Note that this cannot be used with the -D flag as the \"dump"
"\" format always uses a transaction."
msgstr ""
"Jede Anweisung einzeln und nicht in einer Transaktion ausführen. Dies "
"erlaubt den Großteil auch dann zu laden, also die guten Daten, wenn eine "
"Geometrie dabei ist die Fehler verursacht. Beachten Sie bitte das dies nicht "
"gemeinsam mit der -D Flag angegeben werden kann, da das \"dump\" Format "
"immer eine Transaktion verwendet."

#. Tag: term
#: using_postgis_dataman.xml:1576
#, no-c-format
msgid "-W &lt;encoding&gt;"
msgstr "-W &lt;encoding&gt;"

#. Tag: para
#: using_postgis_dataman.xml:1578
#, no-c-format
msgid ""
"Specify encoding of the input data (dbf file). When used, all attributes of "
"the dbf are converted from the specified encoding to UTF8. The resulting SQL "
"output will contain a <code>SET CLIENT_ENCODING to UTF8</code> command, so "
"that the backend will be able to reconvert from UTF8 to whatever encoding "
"the database is configured to use internally."
msgstr ""
"Gibt die Codierung der Eingabedaten (dbf-Datei) an. Wird die Option "
"verwendet, so werden alle Attribute der dbf-Datei von der angegebenen "
"Codierung nach UTF8 konvertiert. Die resultierende SQL-Ausgabe enthält dann "
"den Befehl <code>SET CLIENT_ENCODING to UTF8</code>, damit das Back-end "
"wiederum die Möglichkeit hat, von UTF8 in die, für die interne Nutzung "
"konfigurierte Datenbankcodierung zu decodieren."

#. Tag: term
#: using_postgis_dataman.xml:1588
#, no-c-format
msgid "-N &lt;policy&gt;"
msgstr "-N &lt;policy&gt;"

#. Tag: para
#: using_postgis_dataman.xml:1590
#, no-c-format
msgid "NULL geometries handling policy (insert*,skip,abort)"
msgstr "Umgang mit NULL-Geometrien (insert*, skip, abort)"

#. Tag: term
#: using_postgis_dataman.xml:1596
#, no-c-format
msgid "<term>-n</term>"
msgstr "<term>-n</term>"

#. Tag: para
#: using_postgis_dataman.xml:1598
#, no-c-format
msgid ""
"-n Only import DBF file. If your data has no corresponding shapefile, it "
"will automatically switch to this mode and load just the dbf. So setting "
"this flag is only needed if you have a full shapefile set, and you only want "
"the attribute data and no geometry."
msgstr ""
"-n Es wird nur die *.dbf-Datei importiert. Wenn das Shapefile nicht Ihren "
"Daten entspricht, wird automatisch auf diesen Modus geschaltet und nur die *."
"dbf-Datei geladen. Daher müssen Sie diese Flag nur dann setzen, wenn sie "
"einen vollständigen Shapefile-Satz haben und lediglich die Attributdaten, "
"und nicht die Geometrie, laden wollen."

#. Tag: term
#: using_postgis_dataman.xml:1606
#, no-c-format
msgid "<term>-G</term>"
msgstr "<term>-G</term>"

#. Tag: para
#: using_postgis_dataman.xml:1608
#, no-c-format
msgid ""
"Use geography type instead of geometry (requires lon/lat data) in WGS84 long "
"lat (SRID=4326)"
msgstr ""
"Verwendung des geographischen Datentyps in WGS84 (SRID=4326), anstelle des "
"geometrischen Datentyps (benötigt Längen- und Breitenangaben)."

#. Tag: term
#: using_postgis_dataman.xml:1614
#, no-c-format
msgid "-T &lt;tablespace&gt;"
msgstr "-T &lt;tablespace&gt;"

#. Tag: para
#: using_postgis_dataman.xml:1616
#, no-c-format
msgid ""
"Specify the tablespace for the new table. Indexes will still use the default "
"tablespace unless the -X parameter is also used. The PostgreSQL "
"documentation has a good description on when to use custom tablespaces."
msgstr ""
"Den Tablespace für die neue Tabelle festlegen. Solange der -X Parameter "
"nicht angegeben wird, benutzen die Indizes weiterhin den standardmäßig "
"festgelegten Tablespace. Die PostgreSQL Dokumentation beinhaltet eine gute "
"Beschreibung, wann es sinnvoll ist, eigene Tablespaces zu verwenden."

#. Tag: term
#: using_postgis_dataman.xml:1624
#, no-c-format
msgid "-X &lt;tablespace&gt;"
msgstr "-X &lt;tablespace&gt;"

#. Tag: para
#: using_postgis_dataman.xml:1626
#, no-c-format
msgid ""
"Specify the tablespace for the new table's indexes. This applies to the "
"primary key index, and the GIST spatial index if -I is also used."
msgstr ""
"Den Tablespace bestimmen, in dem die neuen Tabellenindizes angelegt werden "
"sollen. Gilt für den Primärschlüsselindex und wenn \"-l\" verwendet wird, "
"auch für den räumlichen GIST-Index."

#. Tag: para
#: using_postgis_dataman.xml:1634
#, no-c-format
msgid ""
"An example session using the loader to create an input file and uploading it "
"might look like this:"
msgstr ""
"Eine beispielhafte Sitzung, in welcher der Loader verwendet wird, um eine "
"Eingabedatei zu erzeugen und anschließend hochzuladen, könnte folgendermaßen "
"aussehen:"

#. Tag: programlisting
#: using_postgis_dataman.xml:1639
#, no-c-format
msgid ""
"# shp2pgsql -c -D -s 4269 -i -I shaperoads.shp myschema.roadstable &gt; "
"roads.sql\n"
"# psql -d roadsdb -f roads.sql"
msgstr ""
"# shp2pgsql -c -D -s 4269 -i -I shaperoads.shp myschema.roadstable &gt; "
"roads.sql\n"
"# psql -d roadsdb -f roads.sql"

#. Tag: para
#: using_postgis_dataman.xml:1641
#, no-c-format
msgid "A conversion and upload can be done all in one step using UNIX pipes:"
msgstr ""
"Konvertierung und Import können über UNIX-Pipes in einem Schritt erfolgen:"

#. Tag: programlisting
#: using_postgis_dataman.xml:1645
#, no-c-format
msgid "# shp2pgsql shaperoads.shp myschema.roadstable | psql -d roadsdb"
msgstr "# shp2pgsql shaperoads.shp myschema.roadstable | psql -d roadsdb"

#. Tag: title
#: using_postgis_dataman.xml:1650
#, no-c-format
msgid "Retrieving GIS Data"
msgstr "Geodaten abrufen"

#. Tag: para
#: using_postgis_dataman.xml:1652
#, no-c-format
msgid ""
"Data can be extracted from the database using either SQL or the Shape file "
"loader/dumper. In the section on SQL we will discuss some of the operators "
"available to do comparisons and queries on spatial tables."
msgstr ""
"Daten können entweder über SQL oder mit dem Shapefile Loader/Dumper aus der "
"Datenbank entnommen werden. Im Abschnitt über SQL werden einige Operatoren "
"besprochen, die für Vergleiche und Abfragen von Geotabellen zur Verfügung "
"stehen."

#. Tag: title
#: using_postgis_dataman.xml:1658
#, no-c-format
msgid "Using SQL to Retrieve Data"
msgstr "Daten mit SQL abrufen"

#. Tag: para
#: using_postgis_dataman.xml:1660
#, no-c-format
msgid ""
"The most straightforward means of pulling data out of the database is to use "
"a SQL select query to reduce the number of RECORDS and COLUMNS returned and "
"dump the resulting columns into a parsable text file:"
msgstr ""
"Die direkteste Methode, um Daten aus der Datenbank abzurufen, ist eine SQL "
"Select-Anfrage. Dadurch kann die Anzahl der resultierenden Datensätze und "
"Attribute reduziert und in eine lesbare Textdatei überspielt werden:"

#. Tag: programlisting
#: using_postgis_dataman.xml:1665
#, no-c-format
msgid ""
"db=# SELECT road_id, ST_AsText(road_geom) AS geom, road_name FROM roads;\n"
"\n"
"road_id | geom                                    | road_name\n"
"--------+-----------------------------------------+-----------\n"
"          1 | LINESTRING(191232 243118,191108 243242) | Jeff Rd\n"
"          2 | LINESTRING(189141 244158,189265 244817) | Geordie Rd\n"
"          3 | LINESTRING(192783 228138,192612 229814) | Paul St\n"
"          4 | LINESTRING(189412 252431,189631 259122) | Graeme Ave\n"
"          5 | LINESTRING(190131 224148,190871 228134) | Phil Tce\n"
"          6 | LINESTRING(198231 263418,198213 268322) | Dave Cres\n"
"          7 | LINESTRING(218421 284121,224123 241231) | Chris Way\n"
"(6 rows)"
msgstr ""
"db=# SELECT road_id, ST_AsText(road_geom) AS geom, road_name FROM roads;\n"
"\n"
"road_id | geom                                    | road_name\n"
"--------+-----------------------------------------+-----------\n"
"          1 | LINESTRING(191232 243118,191108 243242) | Jeff Rd\n"
"          2 | LINESTRING(189141 244158,189265 244817) | Geordie Rd\n"
"          3 | LINESTRING(192783 228138,192612 229814) | Paul St\n"
"          4 | LINESTRING(189412 252431,189631 259122) | Graeme Ave\n"
"          5 | LINESTRING(190131 224148,190871 228134) | Phil Tce\n"
"          6 | LINESTRING(198231 263418,198213 268322) | Dave Cres\n"
"          7 | LINESTRING(218421 284121,224123 241231) | Chris Way\n"
"(6 rows)"

#. Tag: para
#: using_postgis_dataman.xml:1667
#, no-c-format
msgid ""
"However, there will be times when some kind of restriction is necessary to "
"cut down the number of fields returned. In the case of attribute-based "
"restrictions, just use the same SQL syntax as normal with a non-spatial "
"table. In the case of spatial restrictions, the following operators are "
"available/useful:"
msgstr ""
"Wie auch immer, manchmal wird eine Einschränkung notwendig sein, um die "
"Anzahl der zurückgegebenen Werte zu reduzieren. Falls es sich um eine "
"Beschränkung auf ein Attribut handelt, können Sie dieselbe SQL-Syntax "
"verwenden wie bei jeder anderen Nicht-Geometrietabelle. Für räumliche "
"Beschränkungen sind folgende Operatoren verfügbar/nützlich:"

#. Tag: term
#: using_postgis_dataman.xml:1675
#, no-c-format
msgid "ST_Intersects"
msgstr "ST_Intersects"

#. Tag: para
#: using_postgis_dataman.xml:1678
#, no-c-format
msgid "This function tells whether two geometries share any space."
msgstr ""
"Diese Funktion bestimmt ob sich zwei geometrische Objekte einen gemeinsamen "
"Raum teilen"

#. Tag: term
#: using_postgis_dataman.xml:1683
#, no-c-format
msgid "<term>=</term>"
msgstr "<term>=</term>"

#. Tag: para
#: using_postgis_dataman.xml:1686
#, no-c-format
msgid ""
"This tests whether two geometries are geometrically identical. For example, "
"if 'POLYGON((0 0,1 1,1 0,0 0))' is the same as 'POLYGON((0 0,1 1,1 0,0 "
"0))' (it is)."
msgstr ""
"Überprüft, ob zwei Geoobjekte geometrisch ident sind. Zum Beispiel, ob "
"'POLYGON((0 0,1 1,1 0,0 0))' ident mit 'POLYGON((0 0,1 1,1 0,0 0))'  ist "
"(ist es)."

#. Tag: para
#: using_postgis_dataman.xml:1690
#, no-c-format
msgid "Note: before PostGIS 2.4 this compared only boxes of geometries."
msgstr ""
"Beachte: vor PostGIS 2.4 wuden nur die umschreibenden Rechtecke der "
"Geometrie verglichen."

#. Tag: para
#: using_postgis_dataman.xml:1695
#, no-c-format
msgid ""
"Next, you can use these operators in queries. Note that when specifying "
"geometries and boxes on the SQL command line, you must explicitly turn the "
"string representations into geometries function. The 312 is a fictitious "
"spatial reference system that matches our data. So, for example:"
msgstr ""
"Außerdem können Sie diese Operatoren in Anfragen verwenden. Beachten Sie "
"bitte, wenn Sie eine Geometrie oder eine Box auf der SQL-Befehlszeile "
"eingeben, dass Sie die Zeichensatzdarstellung explizit in eine Geometrie "
"umwandeln müssen. 312 ist ein fiktives Koordinatenreferenzsystem das zu "
"unseren Daten passt. Also, zum Beispiel:"

#. Tag: programlisting
#: using_postgis_dataman.xml:1701
#, no-c-format
msgid ""
"SELECT road_id, road_name\n"
"  FROM roads\n"
"  WHERE roads_geom='SRID=312;LINESTRING(191232 243118,191108 243242)'::"
"geometry;"
msgstr ""
"SELECT road_id, road_name\n"
"  FROM roads\n"
"  WHERE roads_geom='SRID=312;LINESTRING(191232 243118,191108 243242)'::"
"geometry;"

#. Tag: para
#: using_postgis_dataman.xml:1703
#, no-c-format
msgid ""
"The above query would return the single record from the \"ROADS_GEOM\" table "
"in which the geometry was equal to that value."
msgstr ""
"Die obere Abfrage würde einen einzelnen Datensatz aus der Tabelle "
"\"ROADS_GEOM\" zurückgeben, in dem die Geometrie gleich dem angegebenen Wert "
"ist."

#. Tag: para
#: using_postgis_dataman.xml:1706
#, no-c-format
msgid ""
"To check whether some of the roads passes in the area defined by a polygon:"
msgstr "Überprüfung ob einige der Strassen in die Polygonfläche hineinreichen:"

#. Tag: programlisting
#: using_postgis_dataman.xml:1708
#, no-c-format
msgid ""
"SELECT road_id, road_name\n"
"FROM roads\n"
"WHERE ST_Intersects(roads_geom, 'SRID=312;POLYGON((...))');"
msgstr ""
"SELECT road_id, road_name\n"
"FROM roads\n"
"WHERE ST_Intersects(roads_geom, 'SRID=312;POLYGON((...))');"

#. Tag: para
#: using_postgis_dataman.xml:1712
#, no-c-format
msgid ""
"The most common spatial query will probably be a \"frame-based\" query, used "
"by client software, like data browsers and web mappers, to grab a \"map frame"
"\" worth of data for display."
msgstr ""
"Die häufigsten räumlichen Abfragen werden vermutlich in einem bestimmten "
"Ausschnitt ausgeführt. Insbesondere von Client-Software, wie Datenbrowsern "
"und Kartendiensten, die auf diese Weise die Daten für die Darstellung eines "
"\"Kartenausschnitts\" erfassen."

#. Tag: para
#: using_postgis_dataman.xml:1715
#, no-c-format
msgid ""
"When using the \"&amp;&amp;\" operator, you can specify either a BOX3D as "
"the comparison feature or a GEOMETRY. When you specify a GEOMETRY, however, "
"its bounding box will be used for the comparison."
msgstr ""
"Der Operator \"&amp;&amp;\" kann entweder mit einer BOX3D oder mit einer "
"Geometrie verwendet werden. Allerdings wird auch bei einer Geometrie nur das "
"Umgebungsrechteck für den Vergleich herangezogen."

#. Tag: para
#: using_postgis_dataman.xml:1719
#, no-c-format
msgid "Using a \"BOX3D\" object for the frame, such a query looks like this:"
msgstr ""
"Die Abfrage zur Verwendung des \"BOX3D\" Objekts für einen solchen "
"Ausschnitt sieht folgendermaßen aus:"

#. Tag: programlisting
#: using_postgis_dataman.xml:1721
#, no-c-format
msgid ""
"SELECT ST_AsText(roads_geom) AS geom\n"
"FROM roads\n"
"WHERE\n"
"  roads_geom &amp;&amp; ST_MakeEnvelope(191232, 243117,191232, 243119,312);"
msgstr ""
"SELECT ST_AsText(roads_geom) AS geom\n"
"FROM roads\n"
"WHERE\n"
"  roads_geom &amp;&amp; ST_MakeEnvelope(191232, 243117,191232, 243119,312);"

#. Tag: para
#: using_postgis_dataman.xml:1723
#, no-c-format
msgid ""
"Note the use of the SRID 312, to specify the projection of the envelope."
msgstr ""
"Achten Sie auf die Verwendung von SRID=312, welche die Projektion "
"Einhüllenden/Enveloppe bestimmt."

#. Tag: title
#: using_postgis_dataman.xml:1729
#, no-c-format
msgid "Using the Dumper"
msgstr "Verwendung des Dumper"

#. Tag: para
#: using_postgis_dataman.xml:1731
#, no-c-format
msgid ""
"The <filename>pgsql2shp</filename> table dumper connects directly to the "
"database and converts a table (possibly defined by a query) into a shape "
"file. The basic syntax is:"
msgstr ""
"Der Tabellendumper <filename>pgsql2shp</filename> verbindet sich direkt mit "
"der Datenbank und konvertiert eine Tabelle (evtl. durch eine Abfrage "
"festgelegt) in eine Shapedatei. Die grundlegende Syntax lautet:"

#. Tag: programlisting
#: using_postgis_dataman.xml:1735
#, no-c-format
msgid ""
"pgsql2shp [&lt;options&gt;] &lt;database&gt; [&lt;schema&gt;.]&lt;table&gt;"
msgstr ""
"pgsql2shp [&lt;options&gt;] &lt;database&gt; [&lt;schema&gt;.]&lt;table&gt;"

#. Tag: programlisting
#: using_postgis_dataman.xml:1737
#, no-c-format
msgid "pgsql2shp [&lt;options&gt;] &lt;database&gt; &lt;query&gt;"
msgstr "pgsql2shp [&lt;options&gt;] &lt;database&gt; &lt;query&gt;"

#. Tag: para
#: using_postgis_dataman.xml:1739
#, no-c-format
msgid "The commandline options are:"
msgstr "Optionen auf der Befehlszeile:"

#. Tag: term
#: using_postgis_dataman.xml:1743
#, no-c-format
msgid "-f &lt;filename&gt;"
msgstr "-f &lt;filename&gt;"

#. Tag: para
#: using_postgis_dataman.xml:1746
#, no-c-format
msgid "Write the output to a particular filename."
msgstr "Ausgabe in eine bestimmte Datei."

#. Tag: term
#: using_postgis_dataman.xml:1751
#, no-c-format
msgid "-h &lt;host&gt;"
msgstr "-h &lt;host&gt;"

#. Tag: para
#: using_postgis_dataman.xml:1754
#, no-c-format
msgid "The database host to connect to."
msgstr "Der Datenbankserver, mit dem eine Verbindung aufgebaut werden soll."

#. Tag: term
#: using_postgis_dataman.xml:1759
#, no-c-format
msgid "-p &lt;port&gt;"
msgstr "-p &lt;port&gt;"

#. Tag: para
#: using_postgis_dataman.xml:1762
#, no-c-format
msgid "The port to connect to on the database host."
msgstr ""
"Der Port über den der Verbindungsaufbau mit dem Datenbank Server hergestellt "
"werden soll."

#. Tag: term
#: using_postgis_dataman.xml:1767
#, no-c-format
msgid "-P &lt;password&gt;"
msgstr "-P &lt;password&gt;"

#. Tag: para
#: using_postgis_dataman.xml:1770
#, no-c-format
msgid "The password to use when connecting to the database."
msgstr ""
"Das Passwort, das zum Verbindungsaufbau mit der Datenbank verwendet werden "
"soll."

#. Tag: term
#: using_postgis_dataman.xml:1775
#, no-c-format
msgid "-u &lt;user&gt;"
msgstr "-u &lt;user&gt;"

#. Tag: para
#: using_postgis_dataman.xml:1778
#, no-c-format
msgid "The username to use when connecting to the database."
msgstr ""
"Das Benutzername, der zum Verbindungsaufbau mit der Datenbank verwendet "
"werden soll."

#. Tag: term
#: using_postgis_dataman.xml:1783
#, no-c-format
msgid "-g &lt;geometry column&gt;"
msgstr "-g &lt;geometry column&gt;"

#. Tag: para
#: using_postgis_dataman.xml:1786
#, no-c-format
msgid ""
"In the case of tables with multiple geometry columns, the geometry column to "
"use when writing the shape file."
msgstr ""
"Bei Tabellen mit mehreren Geometriespalten jene Geometriespalte, die ins "
"Shapefile geschrieben werden soll."

#. Tag: term
#: using_postgis_dataman.xml:1792
#, no-c-format
msgid "<term>-b</term>"
msgstr "<term>-b</term>"

#. Tag: para
#: using_postgis_dataman.xml:1795
#, no-c-format
msgid ""
"Use a binary cursor. This will make the operation faster, but will not work "
"if any NON-geometry attribute in the table lacks a cast to text."
msgstr ""
"Die Verwendung eines binären Cursors macht die Berechnung schneller; "
"funktioniert aber nur, wenn alle nicht-geometrischen Attribute in den "
"Datentyp \"text\" umgewandelt werden können."

#. Tag: term
#: using_postgis_dataman.xml:1802
#, no-c-format
msgid "<term>-r</term>"
msgstr "<term>-r</term>"

#. Tag: para
#: using_postgis_dataman.xml:1805
#, no-c-format
msgid ""
"Raw mode. Do not drop the <varname>gid</varname> field, or escape column "
"names."
msgstr ""
"RAW-Modus. Das Attribut <varname>gid</varname> wird nicht verworfen und "
"Spaltennamen werden nicht maskiert."

#. Tag: term
#: using_postgis_dataman.xml:1811
#, no-c-format
msgid "-m <varname>filename</varname>"
msgstr "-m <varname>filename</varname>"

#. Tag: para
#: using_postgis_dataman.xml:1813
#, no-c-format
msgid ""
"Remap identifiers to ten character names. The content of the file is lines "
"of two symbols separated by a single white space and no trailing or leading "
"space: VERYLONGSYMBOL SHORTONE ANOTHERVERYLONGSYMBOL SHORTER etc."
msgstr ""
"Bildet die Identifikatoren in Namen mit 10 Zeichen ab. Der Inhalt der Datei "
"besteht aus Zeilen von jeweils zwei durch Leerzeichen getrennten Symbolen, "
"jedoch ohne vor- oder nachgestellte Leerzeichen: VERYLONGSYMBOL SHORTONE "
"ANOTHERVERYLONGSYMBOL SHORTER etc."

#. Tag: title
#: using_postgis_dataman.xml:1826
#, no-c-format
msgid "Building Indexes"
msgstr "Erstellung von Indizes"

#. Tag: para
#: using_postgis_dataman.xml:1828
#, no-c-format
msgid ""
"Indexes are what make using a spatial database for large data sets possible. "
"Without indexing, any search for a feature would require a \"sequential scan"
"\" of every record in the database. Indexing speeds up searching by "
"organizing the data into a search tree which can be quickly traversed to "
"find a particular record. PostgreSQL supports three kinds of indexes by "
"default: B-Tree indexes, SP-GiST and GiST indexes."
msgstr ""
"Indizes ermöglichen das Arbeiten mit großen Datensätzen in einer "
"Geodatenbank. Ohne Indizierung würde jede Featureanfrage einen \"Full Table "
"Scan\" in der Datenbank benötigen. Die Indizierung beschleunigt die Suche, "
"indem die Daten in einem Suchbaum strukturiert werden, der dann schnell "
"durchlaufen werden kann um einen bestimmten Datensatz zu finden. PostgreSQL "
"unterstützt standardmäßig drei Arten von Indizes: B-Baum, SP-GIST und GIST."

#. Tag: para
#: using_postgis_dataman.xml:1837
#, no-c-format
msgid ""
"B-Trees are used for data which can be sorted along one axis; for example, "
"numbers, letters, dates. Spatial data can be sorted along a space-filling "
"curve, Z-order curve or Hilbert curve. This representation however does not "
"allow speeding up common operations."
msgstr ""
"Ein B-Baum wird verwendet, wenn die Daten entlang einer Achse sortiert "
"werden können; wie Zahlen, Buchstaben oder Datumsangaben. Geodaten können "
"entlang einer raumfüllenden Kurve, Z-Kurve oder Hilbert-Kurve sortiert "
"werden. Diese Darstellung erlaubt allerdings keine Beschleunigung der "
"üblichen Operationen."

#. Tag: para
#: using_postgis_dataman.xml:1844
#, no-c-format
msgid ""
"GiST (Generalized Search Trees) indexes break up data into \"things to one "
"side\", \"things which overlap\", \"things which are inside\" and can be "
"used on a wide range of data-types, including GIS data. PostGIS uses an R-"
"Tree index implemented on top of GiST to index GIS data."
msgstr ""
"GiST (Generalized Search Tree) Indizes unterteilen die Daten in \"Dinge auf "
"einer Seite\", \"Dinge die sich überlagern\", \"Dinge die innerhalb liegen"
"\". Sie können auf eine Vielzahl von Datentypen, inklusive Geodaten "
"angewendet werden. Um Geodaten zu indizieren verwendet PostGIS einen R-Baum "
"der auf dem GIST Index aufsetzt."

#. Tag: title
#: using_postgis_dataman.xml:1853
#, no-c-format
msgid "GiST Indexes"
msgstr "GiST-Indizes"

#. Tag: para
#: using_postgis_dataman.xml:1855
#, no-c-format
msgid ""
"GiST stands for \"Generalized Search Tree\" and is a generic form of "
"indexing. In addition to GIS indexing, GiST is used to speed up searches on "
"all kinds of irregular data structures (integer arrays, spectral data, etc) "
"which are not amenable to normal B-Tree indexing."
msgstr ""
"GIST (Generalized Search Tree) ist eine generische Datenstruktur. Zusätzlich "
"zur Indizierung von Geodaten wird GIST auch zur Beschleunigung von Abfragen "
"auf unregelmäßige Datenstrukturen (Ganzzahl-Felder, Spektraldaten, etc.) "
"verwendet, welche über gewöhnlicher B-Baum Indizierung nicht zugänglich sind."

#. Tag: para
#: using_postgis_dataman.xml:1860
#, no-c-format
msgid ""
"Once a GIS data table exceeds a few thousand rows, you will want to build an "
"index to speed up spatial searches of the data (unless all your searches are "
"based on attributes, in which case you'll want to build a normal index on "
"the attribute fields)."
msgstr ""
"Sobald eine Geodatentabelle einige tausend Zeilen überschreitet, werden Sie "
"einen Index erzeugen wollen, um die räumlichen Abfragen auf die Daten zu "
"beschleunigen (außer Ihre Suche basiert lediglich auf Attributen, in diesem "
"Fall werden Sie einen gewöhnlichen Index auf die Attribute setzen)."

#. Tag: para
#: using_postgis_dataman.xml:1865
#, no-c-format
msgid ""
"The syntax for building a GiST index on a \"geometry\" column is as follows:"
msgstr ""
"Die Syntax, mit der ein GIST-Index auf eine Geometriespalte gelegt wird, "
"lautet:"

#. Tag: programlisting
#: using_postgis_dataman.xml:1869
#, no-c-format
msgid "CREATE INDEX [indexname] ON [tablename] USING GIST ( [geometryfield] );"
msgstr ""
"CREATE INDEX [indexname] ON [tablename] USING GIST ( [geometryfield] );"

#. Tag: para
#: using_postgis_dataman.xml:1871
#, no-c-format
msgid ""
"The above syntax will always build a 2D-index. To get the an n-dimensional "
"index for the geometry type, you can create one using this syntax:"
msgstr ""
"Die obere Syntax erzeugt immer einen 2D-Index. Um einen n-dimensionalen "
"Index für den geometrischen Datentyp zu erhalten, können Sie die folgende "
"Syntax verwenden:"

#. Tag: programlisting
#: using_postgis_dataman.xml:1872
#, no-c-format
msgid ""
"CREATE INDEX [indexname] ON [tablename] USING GIST ([geometryfield] "
"gist_geometry_ops_nd);"
msgstr ""
"CREATE INDEX [indexname] ON [tablename] USING GIST ([geometryfield] "
"gist_geometry_ops_nd);"

#. Tag: para
#: using_postgis_dataman.xml:1874
#, no-c-format
msgid ""
"Building a spatial index is a computationally intensive exercise. It also "
"blocks write access to your table for the time it creates, so on a "
"production system you may want to do in in a slower CONCURRENTLY-aware way:"
msgstr ""
"Die Erstellung eines räumlichen Indizes ist eine rechenintensive Aufgabe. "
"Während der Erstellung wird auch der Schreibzugriff auf die Tabelle "
"blockiert. Bei produktiven Systemen empfiehlt sich daher die langsamere "
"Option CONCURRENTLY:"

#. Tag: programlisting
#: using_postgis_dataman.xml:1875
#, no-c-format
msgid ""
"CREATE INDEX CONCURRENTLY [indexname] ON [tablename] USING GIST "
"( [geometryfield] );"
msgstr ""
"CREATE INDEX CONCURRENTLY [indexname] ON [tablename] USING GIST "
"( [geometryfield] );"

#. Tag: para
#: using_postgis_dataman.xml:1877 using_postgis_dataman.xml:1990
#, no-c-format
msgid ""
"After building an index, it is sometimes helpful to force PostgreSQL to "
"collect table statistics, which are used to optimize query plans:"
msgstr ""
"Nachdem ein Index aufgebaut wurde sollte PostgreSQL gezwungen werden die "
"Tabellenstatistik zu sammeln, da diese  zur Optmierung der Auswertungspläne "
"verwendet wird:"

#. Tag: programlisting
#: using_postgis_dataman.xml:1880 using_postgis_dataman.xml:1993
#, no-c-format
msgid "VACUUM ANALYZE [table_name] [(column_name)];"
msgstr "VACUUM ANALYZE [table_name] [(column_name)];"

#. Tag: title
#: using_postgis_dataman.xml:1885
#, no-c-format
msgid "BRIN Indexes"
msgstr "BRIN Indizes"

#. Tag: para
#: using_postgis_dataman.xml:1887
#, no-c-format
msgid ""
"BRIN stands for \"Block Range Index\" and is a generic form of indexing that "
"has been introduced in PostgreSQL 9.5. BRIN is a lossy kind of index, and "
"its main usage is to provide a compromise for both read and write "
"performance. Its primary goal is to handle very large tables for which some "
"of the columns have some natural correlation with their physical location "
"within the table. In addition to GIS indexing, BRIN is used to speed up "
"searches on various kinds of regular or irregular data structures (integer, "
"arrays etc)."
msgstr ""
"Die Bezeichnung BRIN steht für \"Block Range Index\", eine generische Form "
"des Indizierens und wurde mit PostgreSQL 9.5 eingeführt. BRIN ist ein "
"verlustbehafteter Index, dessen Hauptzweck ist, einen Kompromiss sowohl bei "
"der Lese- als auch bei der Schreibgeschwindigkeit anzubieten. Der "
"Hauptverwendungszweck liegt bei sehr großen Tabellen, in denen einige "
"Spalten einen natürlichen Bezug zu dem physischen Speicherplatz innerhalb "
"der Tabelle haben. Zusätzlich zur Indizierung von GIS-Daten, werden BRIN-"
"Indizes zur Beschleunigung von Suchabfragen auf unterschiedliche regelmäßige "
"und unregelmäßige Datenstrukturen (Ganzzahlen, Felder etc.) verwendet."

#. Tag: para
#: using_postgis_dataman.xml:1896
#, no-c-format
msgid ""
"Once a GIS data table exceeds a few thousand rows, you will want to build an "
"index to speed up spatial searches of the data (unless all your searches are "
"based on attributes, in which case you'll want to build a normal index on "
"the attribute fields). GiST indexes are really performant as long as their "
"size doesn't exceed the amount of RAM available for the database, and as "
"long as you can afford the storage size, and the penalty in write workload. "
"Otherwise, BRIN index can be considered as an alternative."
msgstr ""
"Sobald eine Geodatentabelle ein paar tausend Zeilen überschreitet, werden "
"Sie einen Index erzeugen wollen, um die räumlichen Abfragen auf die Daten zu "
"beschleunigen (außer Ihre Suche basiert lediglich auf Attributen, in diesem "
"Fall werden Sie einen gewöhnlichen Index auf die Attribute setzen). GIST "
"Indizes sind sehr performant, solange ihre Dateigröße den verfügbaren "
"Arbeitsspeicher der Datenbank nicht überschreitet, genügend "
"Festplattenspeicher vorhanden ist und die Systembelastung durch "
"Schreibvorgänge akzeptiert werden kann. Andernfalls bietet der BRIN Index "
"eine Alternative."

#. Tag: para
#: using_postgis_dataman.xml:1905
#, no-c-format
msgid ""
"The idea of a BRIN index is to store only the bouding box englobing all the "
"geometries contained in all the rows in a set of table blocks, called a "
"range. Obviously, this indexing method will only be efficient if the data is "
"physically ordered in a way where the resulting bouding boxes for block "
"ranges will be mutually exclusive. The resulting index will be really small, "
"but will be less efficient than a GiST index in many cases."
msgstr ""
"Die Idee hinter einem BRIN-Index ist, dass nur das Umgebungsrechteck "
"abgespeichert wird, dass die gesamte Geometrie eines oder mehrerer "
"Tabellenblöcke umschließt; dies wird als \"Range\" bezeichnet. Es ist klar, "
"dass diese Indizierungsmethode nur dann effizient sein kann, wenn die Daten "
"physikalisch so angeordnet sind, dass sich die resultierenden "
"Umgebungsrechtecke der \"Block Ranges\" gegenseitig ausschließen. Der "
"resultierende Index ist zwar sehr klein, in vielen Fällen allerdings weniger "
"effizient als ein GIST Index."

#. Tag: para
#: using_postgis_dataman.xml:1913
#, no-c-format
msgid ""
"Building a BRIN index is way less intensive than building a GiST index. It's "
"quite common to build a BRIN index in more than ten time less than a GiST "
"index would have required. As a BRIN index only store one bouding box for "
"one to many table blocks, it's pretty common to consume up to a thousand "
"time less disk space for this kind of indexes."
msgstr ""
"Die Erstellung eines BRIN-Index benötigt wesentlich weniger Zeit, als die "
"Erstellung eines GIST-Index. Es ist durchaus üblich, dass die Erstellung des "
"BRIN Index mehr als zehnmal so schnell ist, als die eines GIST Index. Da ein "
"BRIN Index nur ein Umgebungsrechteck für einen oder mehrere Tabellenblöcke "
"speichert, benötigt dieser oft bis zu tausendmal weniger Festplattenspeicher."

#. Tag: para
#: using_postgis_dataman.xml:1919
#, no-c-format
msgid ""
"You can choose the number of blocks to summarize in a range. If you decrease "
"this number, the index will be bigger but will probably help to get better "
"performance."
msgstr ""
"Sie können die Anzahl der Blöcke festlegen, die zu einen \"Range\" "
"aufsummiert werden sollen. Wenn Sie die Anzahl verringern, wird der Index "
"zwar größer, höchstwahrscheinlich aber zu einer besseren Performanz "
"verhelfen."

#. Tag: para
#: using_postgis_dataman.xml:1923
#, no-c-format
msgid ""
"The syntax for building a BRIN index on a \"geometry\" column is as follows:"
msgstr ""
"Der Syntax zur Erstellung eines BRIN-Indizes auf eine geometrische Spalte "
"lautet wie folgt:"

#. Tag: programlisting
#: using_postgis_dataman.xml:1926
#, no-c-format
msgid "CREATE INDEX [indexname] ON [tablename] USING BRIN ( [geometryfield] );"
msgstr ""
"CREATE INDEX [indexname] ON [tablename] USING BRIN ( [geometryfield] );"

#. Tag: para
#: using_postgis_dataman.xml:1927
#, no-c-format
msgid ""
"The above syntax will always build a 2D-index. To get a 3D-dimensional "
"index, you can create one using this syntax"
msgstr ""
"Die obere Syntax erzeugt einen 2D-Index. Um einen 3-dimensionalen Index zu "
"erhalten, können Sie die folgende Syntax verwenden:"

#. Tag: programlisting
#: using_postgis_dataman.xml:1928
#, no-c-format
msgid ""
"CREATE INDEX [indexname] ON [tablename] USING BRIN ([geometryfield] "
"brin_geometry_inclusion_ops_3d);"
msgstr ""
"CREATE INDEX [indexname] ON [tablename] USING BRIN ([geometryfield] "
"brin_geometry_inclusion_ops_3d);"

#. Tag: para
#: using_postgis_dataman.xml:1929
#, no-c-format
msgid "You can also get a 4D-dimensional index using the 4D operator class"
msgstr ""
"Sie können auch einen 4-dimensionalen Index über die 4D-Operatorklasse "
"erstellen"

#. Tag: programlisting
#: using_postgis_dataman.xml:1930
#, no-c-format
msgid ""
"CREATE INDEX [indexname] ON [tablename] USING BRIN ([geometryfield] "
"brin_geometry_inclusion_ops_4d);"
msgstr ""
"CREATE INDEX [indexname] ON [tablename] USING BRIN ([geometryfield] "
"brin_geometry_inclusion_ops_4d);"

#. Tag: para
#: using_postgis_dataman.xml:1931
#, no-c-format
msgid ""
"These above syntaxes will use the default number or block in a range, which "
"is 128. To specify the number of blocks you want to summarise in a range, "
"you can create one using this syntax"
msgstr ""
"Die oberen Syntaxen verwenden die Standardeinstellung für die Anzahl der "
"Blöcke in einem \"Range\", nämlich 128. Wenn Sie die Anzahl der Blöcke, die "
"in einem Range zusammengefasst werden sollen, selbst festlegen wollen, "
"verwenden Sie bitte die folgende Syntax"

#. Tag: programlisting
#: using_postgis_dataman.xml:1932
#, no-c-format
msgid ""
"CREATE INDEX [indexname] ON [tablename] USING BRIN ( [geometryfield] ) WITH "
"(pages_per_range = [number]);"
msgstr ""
"CREATE INDEX [indexname] ON [tablename] USING BRIN ( [geometryfield] ) WITH "
"(pages_per_range = [number]);"

#. Tag: para
#: using_postgis_dataman.xml:1933
#, no-c-format
msgid ""
"Also, keep in mind that a BRIN index will only store one index value for a "
"large number of rows. If your table stores geometries with a mixed number of "
"dimensions, it's likely that the resulting index will have poor performance. "
"You can avoid this drop of performance by choosing the operator class whith "
"the least number of dimensions of the stored geometries"
msgstr ""
"Beachten Sie bitte auch, dass ein BRIN Index nur einen Indexwert für eine "
"große Anzahl von Zeilen speichert. Wenn Ihre Tabelle eine Geometrie mit "
"unterschiedlichen Dimensionen speichert, dann ist es wahrscheinlich dass der "
"Index eine schlechte Performanz aufweist. Sie können diesen "
"Performanzrückgang vermeiden, indem Sie die Operatorklasse mit der "
"niedrigsten Dimension der gespeicherten Geometrie wählen."

#. Tag: para
#: using_postgis_dataman.xml:1941
#, no-c-format
msgid ""
"Also the \"geography\" datatype is supported for BRIN indexing. The syntax "
"for building a BRIN index on a \"geography\" column is as follows:"
msgstr ""
"Der BRIN-Index wird auch vom geographischen Datentyp unterstützt. Die Syntax "
"zur Erstellung eines BRIN-Index auf eine \"geographische\" Spalte lautet wie "
"folgt:"

#. Tag: programlisting
#: using_postgis_dataman.xml:1944
#, no-c-format
msgid ""
"CREATE INDEX [indexname] ON [tablename] USING BRIN ( [geographyfield] );"
msgstr ""
"CREATE INDEX [indexname] ON [tablename] USING BRIN ( [geographyfield] );"

#. Tag: para
#: using_postgis_dataman.xml:1945
#, no-c-format
msgid ""
"The above syntax will always build a 2D-index for geospatial objects on the "
"spheroid."
msgstr ""
"Die obere Syntax erzeugt den 2D-Index für Geoobjekte auf dem "
"Referenzellipsoid."

#. Tag: para
#: using_postgis_dataman.xml:1947
#, no-c-format
msgid ""
"Currently, just the \"inclusion support\" is considered here, meaning that "
"just <varname>&amp;&amp;</varname>, <varname>~</varname> and <varname>@</"
"varname> operators can be used for the 2D cases (both for \"geometry\" and "
"for \"geography\"), and just the <varname>&amp;&amp;&amp;</varname> operator "
"can be used for the 3D geometries. There is no support for kNN searches at "
"the moment."
msgstr ""
"Aktuell wird hierbei nur die \"Inklusionsunterstützung\" betrachtet; d.h. "
"dass nur die Operatoren <varname>&amp;&amp;</varname>, <varname>~</varname> "
"und <varname>@</varname> für 2D (sowohl für den \"geometrischen\", als auch "
"für den \"geographischen\" Datentyp) und nur der Operator <varname>&amp;&amp;"
"&amp;</varname> für 3D-Geometrie verwendet werden kann. Die kNN-Suche wird "
"zur Zeit nicht unterstützt."

#. Tag: title
#: using_postgis_dataman.xml:1956
#, no-c-format
msgid "SP-GiST Indexes"
msgstr "SP-GiST Indizes"

#. Tag: para
#: using_postgis_dataman.xml:1958
#, no-c-format
msgid ""
"SP-GiST stands for \"Space-Partitioned Generalized Search Tree\" and is a "
"generic form of indexing that supports partitioned search trees, such as "
"quad-trees, k-d trees, and radix trees (tries). The common feature of these "
"data structures is that they repeatedly divide the search space into "
"partitions that need not be of equal size. In addition to GIS indexing, SP-"
"GiST is used to speed up searches on many kinds of data, such as phone "
"routing, ip routing, substring search, etc."
msgstr ""
"SP-GiST steht als Abkürzung für \"Space-Partitioned Generalized Search Tree"
"\", ein generischer Indextyp der partitionierte Baumstrukturen, wie "
"Quadtree, k-d Baum und Radix-Trie unterstützt. Diese Datenstrukturen haben "
"die gemeinsame Eigenschaft, dass sie den Suchraum in mehrere Partitionen "
"unterteilen, die unterschiedlich groß sein können. Zusätzlich zur "
"Indizierung von Geodaten wird der SP-GIST Index zur Beschleunigung der Suche "
"von vielen Datentypen verwendet, wie bei Telefon Routing, IP Routing, String-"
"Matching-Algorithmen, etc."

#. Tag: para
#: using_postgis_dataman.xml:1966
#, no-c-format
msgid ""
"As it is the case for GiST indexes, SP-GiST indexes are lossy, in the sense "
"that they store the bounding box englobing the spatial objects. SP-GiST "
"indexes can be considered as an alternative to GiST indexes. The performance "
"tests reveal that SP-GiST indexes are especially beneficial when there are "
"many overlapping objects, that is, with so-called “spaghetti data”."
msgstr ""
"So wie der GiST Index, ist auch der SP-GiST Index insofern nicht "
"verlustfrei, da nur die umschreibenden Rechtecke der Geoobjekte gespeichert "
"werden. Der SP-GiST Index kann als Alternative zum GiST Index gesehen "
"werden. Die Performanztests zeigten, dass der SP-GiST Index insbesondere bei "
"vielen überlappenden Objekten Vorteile haben, wie dies bei sogenannten "
"\"Spaghettidaten\" der Fall ist."

#. Tag: para
#: using_postgis_dataman.xml:1973
#, no-c-format
msgid ""
"Once a GIS data table exceeds a few thousand rows, an SP-GiST index may be "
"used to speed up spatial searches of the data. The syntax for building an SP-"
"GiST index on a \"geometry\" column is as follows:"
msgstr ""
"Sobald eine Geodatentabelle einige tausend Zeilen überschreitet, kann es "
"sinnvoll sein einen SP-GIST Index zu erzeugen, um die räumlichen Abfragen "
"auf die Daten zu beschleunigen. Die Syntax zur Erstellung eines SP-GIST "
"Index auf eine \"Geometriespalte\" lautet:"

#. Tag: programlisting
#: using_postgis_dataman.xml:1977
#, no-c-format
msgid ""
"CREATE INDEX [indexname] ON [tablename] USING SPGIST ( [geometryfield] );"
msgstr ""
"CREATE INDEX [indexname] ON [tablename] USING SPGIST ( [geometryfield] );"

#. Tag: para
#: using_postgis_dataman.xml:1979
#, no-c-format
msgid ""
"The above syntax will build a 2-dimensional index. A 3-dimensional index for "
"the geometry type can be created using the 3D operator class:"
msgstr ""
"Die obere Syntax erzeugt einen 2D-Index. Ein 3-dimensionaler Index für den "
"geometrischen Datentyp können Sie mit der 3D Operatorklasse erstellen:"

#. Tag: programlisting
#: using_postgis_dataman.xml:1982
#, no-c-format
msgid ""
"CREATE INDEX [indexname] ON [tablename] USING SPGIST ([geometryfield] "
"spgist_geometry_ops_3d);"
msgstr ""
"CREATE INDEX [indexname] ON [tablename] USING SPGIST ([geometryfield] "
"spgist_geometry_ops_3d);"

#. Tag: para
#: using_postgis_dataman.xml:1984
#, no-c-format
msgid ""
"Building a spatial index is a computationally intensive operation. It also "
"blocks write access to your table for the time it creates, so on a "
"production system you may want to do in in a slower CONCURRENTLY-aware way:"
msgstr ""
"Die Erstellung eines räumlichen Indizes ist eine rechenintensive Aufgabe. "
"Während der Erstellung wird auch der Schreibzugriff auf die Tabelle "
"blockiert. Bei produktiven Systemen empfiehlt sich daher die langsamere "
"Option CONCURRENTLY:"

#. Tag: programlisting
#: using_postgis_dataman.xml:1988
#, no-c-format
msgid ""
"CREATE INDEX CONCURRENTLY [indexname] ON [tablename] USING SPGIST "
"( [geometryfield] );"
msgstr ""
"CREATE INDEX CONCURRENTLY [indexname] ON [tablename] USING SPGIST "
"( [geometryfield] );"

#. Tag: para
#: using_postgis_dataman.xml:1995
#, no-c-format
msgid ""
"An SP-GiST index can accelerate queries involving the following operators:"
msgstr ""
"Ein SP-GiST Index kann Abfragen mit folgenden Operatoren beschleunigen:"

#. Tag: para
#: using_postgis_dataman.xml:1997
#, no-c-format
msgid ""
"&lt;&lt;, &amp;&lt;, &amp;&gt;, &gt;&gt;, &lt;&lt;|, &amp;&lt;|, |&amp;&gt;, "
"|&gt;&gt;, &amp;&amp;, @&gt;, &lt;@, and ~=, for 2-dimensional indexes,"
msgstr ""
"&lt;&lt;, &amp;&lt;, &amp;&gt;, &gt;&gt;, &lt;&lt;|, &amp;&lt;|, |&amp;&gt;, "
"|&gt;&gt;, &amp;&amp;, @&gt;, &lt;@, and ~=, für 2-dimensionale Iindices,"

#. Tag: para
#: using_postgis_dataman.xml:1998
#, no-c-format
msgid "&amp;/&amp;, ~==, @&gt;&gt;, and &lt;&lt;@, for 3-dimensional indexes."
msgstr ""
"&amp;/&amp;, ~==, @&gt;&gt;, and &lt;&lt;@, für 3-dimensionale Indices."

#. Tag: para
#: using_postgis_dataman.xml:2000
#, no-c-format
msgid "There is no support for kNN searches at the moment."
msgstr "kNN Suche wird zurzeit nicht unterstützt."

#. Tag: title
#: using_postgis_dataman.xml:2003
#, no-c-format
msgid "Using Indexes"
msgstr "Verwendung von Indizes"

#. Tag: para
#: using_postgis_dataman.xml:2005
#, no-c-format
msgid ""
"Ordinarily, indexes invisibly speed up data access: once the index is built, "
"the query planner transparently decides when to use index information to "
"speed up a query plan. Unfortunately, the PostgreSQL query planner sometimes "
"does not optimize the use of GiST indexes well, so sometimes searches which "
"should use a spatial index instead may perform a sequential scan of the "
"whole table."
msgstr ""
"Üblicherweise beschleunigen Indizes den Datenzugriff: Sobald der Index "
"aufgebaut ist, entscheidet der Anfrageoptimierer, ob der Index den "
"Auswertungsplan bescheunigt. Unglücklicherweise optimiert der "
"Anfrageoptimierer von PostgreSQL die Verwendung von GIST Indizes nicht sehr "
"gut, so dass manchmal eine Suche, welche die Verwendung eines räumlichen "
"Index bedingen sollte, über einen Full Table Scan ausgeführt wird."

#. Tag: para
#: using_postgis_dataman.xml:2012
#, no-c-format
msgid ""
"If you find your spatial indexes are not being used (or your attribute "
"indexes, for that matter) there are a couple things you can do:"
msgstr ""
"Wenn Sie bemerken, dass Ihre räumlichen Indizes (oder Ihre Attributindizes) "
"nicht verwendet werden, gibt es mehrere Möglichkeiten:"

#. Tag: para
#: using_postgis_dataman.xml:2018
#, no-c-format
msgid ""
"Firstly, read query plan and check your query actually tries to compute the "
"thing you need. A runaway JOIN condition, either forgotten or to the wrong "
"table, can unexpectedly bring you all of your table multiple times. To get "
"query plan, add EXPLAIN keyword in front of your query."
msgstr ""
"Zunächst sollten Sie sich den Auswertungsplan ansehen und überprüfen ob Ihre "
"Abfrage tatsächlich das berechnet was Sie benötigen. Eine unkontrollierte "
"Join-Bedingung, entweder vergessen oder auf eine falsche Tabelle gesetzt, "
"kann alle Datensätze Ihrer Tabelle mehrmals hinzuziehen. Fügen Sie das "
"Schlüsselwort EXPLAIN an den Anfang Ihrer bAbfrage, um den Auswertungsplan "
"zu erhalten."

#. Tag: para
#: using_postgis_dataman.xml:2025
#, no-c-format
msgid ""
"Second, make sure statistics are gathered about the number and distributions "
"of values in a table, to provide the query planner with better information "
"to make decisions around index usage. <command>VACUUM ANALYZE</command> will "
"compute both."
msgstr ""
"Als nächstes sollten Sie sicherstellen, dass eine Statistik über die Anzahl "
"und die Verteilung der Tabellenwerte erfasst wurde, damit dem "
"Anfrageoptimierer bessere Informationen zur Entscheidungsfindung bezüglich "
"zu verwendender Indizes zur Verfügung steht. <command>VACUUM ANALYZE</"
"command> errechnet beide."

#. Tag: para
#: using_postgis_dataman.xml:2030
#, no-c-format
msgid ""
"You should regularly vacuum your databases anyways - many PostgreSQL DBAs "
"have <command>VACUUM</command> run as an off-peak cron job on a regular "
"basis."
msgstr ""
"Sie sollten ohnehin regelmäßig ein Vacuum Ihrer Datenbanken durchführen - "
"viele PostgreSQL DBAs führen ein regelmäßiges<command>VACUUM</command> "
"außerhalb der Spitzenzeiten mittels Cronjob aus."

#. Tag: para
#: using_postgis_dataman.xml:2035
#, no-c-format
msgid ""
"If vacuuming does not help, you can temporarily force the planner to use the "
"index information by using the <command>set enable_seqscan to off;</command> "
"command. This way you can check whether planner is at all capable to "
"generate an index accelerated query plan for your query. You should only use "
"this command only for debug: generally speaking, the planner knows better "
"than you do about when to use indexes. Once you have run your query, do not "
"forget to set <varname>ENABLE_SEQSCAN</varname> back on, so that other "
"queries will utilize the planner as normal."
msgstr ""
"Wenn VACUUM nicht hilft, können Sie den Anfrageoptimierer vorübergehend dazu "
"zwingen den Index zu verwenden, indem Sie den Befehl <command>set "
"enable_seqscan to off;</command> ausführen. Auf diese Weise können Sie "
"feststellen, ob es dem Anfrageoptimierer überhaupt möglich ist, einen "
"indexbeschleunigten Auswertungsplan für Ihre Abfrage zu erstellen. Sie "
"sollten diesen Befehl nur zu Testzwecken: d.h. der Anfrageoptimierer weiß am "
"besten Bescheid wann welcher Index verwendet werden soll. Sobald Sie Ihre "
"Abfrage ausgeführt haben, sollten Sie daher <varname>ENABLE_SEQSCAN</"
"varname> wieder auf ON stellen, damit weitere Abfragen den Anfrageoptimierer "
"wie üblich nutzen können."

#. Tag: para
#: using_postgis_dataman.xml:2047
#, no-c-format
msgid ""
"If <command>set enable_seqscan to off;</command> helps your query to run, "
"your Postgres is likely not tuned for your hardware. If you find the planner "
"wrong about the cost of sequential vs index scans try reducing the value of "
"<varname>random_page_cost</varname> in postgresql.conf or using <command>set "
"random_page_cost to 1.1;</command>. Default value for the parameter is 4, "
"try setting it to 1 (on SSD) or 2 (on fast magnetic disks). Decreasing the "
"value makes the planner more inclined of using Index scans."
msgstr ""
"Wenn <command>set enable_seqscan to off;</command> bei Ihrer Abfrage hilft, "
"dann ist Ihr Postgres vermutlich nicht mit Ihrer Hardware abgestimmt. Wenn "
"Sie herausfinden, daß sich der Anfrageoptimierer bezüglich der Kosten des "
"Full Table Scan im Verhältnis zum Index Scan irrt, können Sie versuchen den "
"Wert von <varname>randam_page_cost</varname> in \"postgresql.conf\" zu "
"reduzieren, oder <command>set random_page_cost to 1.1;</command> ausführen. "
"Der Standardwert des Parameters ist 4, versuchen Sie ihn auf 1 (auf einer "
"SSD) oder auf 2 (auf einem schnellen magnetischen Festplattenlaufwerk) zu "
"setzen. Eine Verringerung des Wertes führt dazu, dass der Anfrageoptimierer "
"eher den Index Scan verwendet."

#. Tag: para
#: using_postgis_dataman.xml:2057
#, no-c-format
msgid ""
"If <command>set enable_seqscan to off;</command> does not help your query, "
"it may happen you use a construction Postgres is not yet able to untangle. A "
"subquery with inline select is one example - you need to rewrite it to the "
"form planner can optimize, say, a LATERAL JOIN."
msgstr ""
"Wenn<command>set enable_seqscan to off;</command> bei Ihrer Abfrage nicht "
"hilft, kann es sein, dass Sie ein Konstrukt verwenden das Postgres noch "
"nicht entwirren kann. Eine Unterabfrage mit einem Inlineselect wäre so ein "
"Fall -Sie müssen dies in eine Form bringen, die der Anfrageoptimierer nützen "
"kann, z.B. mit einem LATERAL JOIN."

#. Tag: title
#: using_postgis_dataman.xml:2068
#, no-c-format
msgid "Complex Queries"
msgstr "Komplexe Abfragen"

#. Tag: para
#: using_postgis_dataman.xml:2070
#, no-c-format
msgid ""
"The <emphasis>raison d'etre</emphasis> of spatial database functionality is "
"performing queries inside the database which would ordinarily require "
"desktop GIS functionality. Using PostGIS effectively requires knowing what "
"spatial functions are available, and ensuring that appropriate indexes are "
"in place to provide good performance. The SRID of 312 used in these examples "
"is purely for demonstration. You should be using a REAL SRID listed in the "
"the spatial_ref_sys table and one that matches the projection of your data. "
"If your data has no spatial reference system specified, you should be "
"THINKING very thoughtfully why it doesn't and maybe it should."
msgstr ""
"<emphasis>Sinn und Zweck</emphasis> der Geodatenbankfunktionalität ist, "
"Abfragen innerhalb der Datenbank auszuführen, welche üblicherweise die "
"Funktionalität eines Desktop-GIS benötigen würden. Um PostGIS effizient zu "
"nutzen, müssen Sie die verfügbaren räumlichen Funktionen kennen und "
"sicherstellen, dass die geeigneten Indizes vorhanden sind um eine gute "
"Performanz zu gewährleisten. Die SRID von 312, die in diesen Beispielen "
"verwendet wird, ist für bloße Demonstrationszwecke gedacht. Sie sollten eine "
"ECHTE SRID aus der Tabelle \"spatial_ref_sys\" verwenden, die auch mit der "
"Projektion Ihrer Daten übereinstimmen muss. Falls Ihren Daten kein "
"Koordinatenreferenzsystem zugewiesen ist, sollten Sie genau eruieren warum "
"dies so ist."

#. Tag: para
#: using_postgis_dataman.xml:2078
#, no-c-format
msgid ""
"If your reason is because you are modeling something that doesn't have a "
"geographic spatial reference system defined such as the internals of a "
"molecule or the floorplan of a not yet built amusement park then that's "
"fine. If the location of the amusement park has been planned however, then "
"it would make sense to use a suitable planar coordinate system for that "
"location if nothing more than to ensure the amusement part is not "
"trespassing on already existing structures."
msgstr ""
"Wenn der Grund darin liegt, dass Sie etwas modellieren, für dass kein "
"Koordinatenreferenzsystem festgelegt ist, wie der innere Aufbau eines "
"Moleküls oder der Grundriss eines noch nicht gebauten Vergnügungsparks, so "
"ist dies in Ordnung. Wenn der Standort des Vergnügungsparks bereits geplant "
"wurde, dann ist die Wahl eines geeigneten Koordinatenreferenzsystems "
"sinnvoll, auch wenn es nur darum geht sicherzustellen, dass der "
"Vergnügungspark keine bereits bestehenden Strukturen überdeckt."

#. Tag: para
#: using_postgis_dataman.xml:2082
#, no-c-format
msgid ""
"Even in the case where you are planning a Mars expedition to transport the "
"human race in the event of a nuclear holocaust and you want to map out the "
"Mars planet for rehabitation, you can use a non-earthly coordinate system "
"such as <ulink url=\"http://spatialreference.org/ref/iau2000/mars-2000/"
"\">Mars 2000</ulink> make one up and insert it in the "
"<varname>spatial_ref_sys</varname> table. Though this Mars coordinate system "
"is a non-planar one (it's in degrees spheroidal), you can use it with the "
"geography type to have your length and proximity measurements in meters "
"instead of degrees."
msgstr ""
"Sogar wenn Sie eine Mars Expedition planen, um die menschliche Rasse nach "
"einem nuklearen Holocaust zu transportieren und Sie den Planeten Mars für "
"die Besiedelung kartieren wollen, können Sie ein Koordinatenreferenzsystem "
"wie <ulink url=\"http://spatialreference.org/ref/iau2000/mars-2000/\">Mars "
"2000</ulink> erstellen und dieses in die Tabelle <varname>spatial_ref_sys</"
"varname> einfügen. Obwohl dieses Koordinatensystem für den Mars nicht planar "
"ist (es ist in Grad des Referenzellipsoids), können Sie den geographischen "
"Datentyp nutzen, um Längen- und Abstandsmessungen in Meter anstatt in Grad "
"anzuzeigen."

#. Tag: title
#: using_postgis_dataman.xml:2088
#, no-c-format
msgid "Taking Advantage of Indexes"
msgstr "Vorteile von Indizes nutzen"

#. Tag: para
#: using_postgis_dataman.xml:2090
#, no-c-format
msgid ""
"When constructing a query it is important to remember that only the bounding-"
"box-based operators such as &amp;&amp; can take advantage of the GiST "
"spatial index. Functions such as <varname>ST_Distance()</varname> cannot use "
"the index to optimize their operation. For example, the following query "
"would be quite slow on a large table:"
msgstr ""
"Wenn Sie eine Abfrage erstellen, müssen Sie beachten, dass nur die auf den "
"umschreibenden Rechtecken basierenden Operatoren wie &amp;&amp; die Vorteile "
"eines räumlichen GIST Index ausnutzen können. Funktionen wie "
"<varname>ST_Distance()</varname> können den Index nicht zur Optimierung "
"heranziehen. Zum Beispiel würde die folgende Abfrage auf eine große Tabelle "
"ziemlich langsam ablaufen:"

#. Tag: programlisting
#: using_postgis_dataman.xml:2097
#, no-c-format
msgid ""
"SELECT the_geom\n"
"FROM geom_table\n"
"WHERE ST_Distance(the_geom, 'SRID=312;POINT(100000 200000)') &lt; 100"
msgstr ""
"SELECT the_geom\n"
"FROM geom_table\n"
"WHERE ST_Distance(the_geom, 'SRID=312;POINT(100000 200000)') &lt; 100"

#. Tag: para
#: using_postgis_dataman.xml:2099
#, no-c-format
msgid ""
"This query is selecting all the geometries in geom_table which are within "
"100 units of the point (100000, 200000). It will be slow because it is "
"calculating the distance between each point in the table and our specified "
"point, ie. one <varname>ST_Distance()</varname> calculation for each row in "
"the table. We can avoid this by using the single step index accelerated "
"function ST_DWithin to reduce the number of distance calculations required:"
msgstr ""
"Diese Abfrage wählt die geometrischen Objekte der Tabelle \"geom_table\" "
"aus, die weniger als 100 Einheiten von dem Punkt (100000, 200000) entfernt "
"liegen. Sie ist sehr langsam, da die Entfernung zwischen jedem Punkt in der "
"Tabelle und dem gegebenen Punkt berechnet werden muss, d.h. eine "
"<varname>ST_Distance()</varname> Berechnung pro Tabellenzeile. Wir können "
"dies vermeiden, indem wir die indexbeschleunigte Einstufenfunktion "
"ST_DWithin verwenden und so die Anzahl der benötigten "
"Entfernungsberechnungen verringern:"

#. Tag: programlisting
#: using_postgis_dataman.xml:2107
#, no-c-format
msgid ""
"SELECT the_geom\n"
"FROM geom_table\n"
"WHERE ST_DWithin(the_geom, 'SRID=312;POINT(100000 200000)', 100)"
msgstr ""
"SELECT the_geom\n"
"FROM geom_table\n"
"WHERE ST_DWithin(the_geom, 'SRID=312;POINT(100000 200000)', 100)"

#. Tag: para
#: using_postgis_dataman.xml:2109
#, no-c-format
msgid ""
"This query selects the same geometries, but it does it in a more efficient "
"way. Assuming there is a GiST index on the_geom, the query planner will "
"recognize that it can use the index to reduce the number of rows before "
"calculating the result of the <varname>ST_Distance()</varname> function. "
"Notice that the <varname>ST_MakeEnvelope</varname> geometry which is used in "
"the &amp;&amp; operation is a 200 unit square box centered on the original "
"point - this is our \"query box\". The &amp;&amp; operator uses the index to "
"quickly reduce the result set down to only those geometries which have "
"bounding boxes that overlap the \"query box\". Assuming that our query box "
"is much smaller than the extents of the entire geometry table, this will "
"drastically reduce the number of distance calculations that need to be done."
msgstr ""
"Diese Anfrage wählt dieselben geometrischen Objekte aus, allerdings auf "
"effizientere Weise. Angenommen es existiert ein GIST Index auf der Spalte "
"\"the_geom\" und der Anfrageoptimierer erkennt, dass der Index angewendet "
"werden kann, um die Zeilenanzahl zu verringern, bevor das Ergebnis durch die "
"Funktion <varname>ST_Distance()</varname> errechnet wird. Anmerkung: die "
"Geometrie <varname>ST_MakeEnvelope</varname>, die vom Operator \"&amp;&amp;"
"\" verwendet wird, ist ein Quadrat mit einer Seitenlänge von 200 Einheiten, "
"dessen Mittelpunkt auf dem ursprünglichen Punkt liegt - dies ist unsere "
"\"Abfrage Box\". Der Operator \"&amp;&amp;\" verwendet diesen Index, um die "
"Ergebnismenge rasch auf die Geometrie zu reduzieren, deren "
"Umgebungsrechtecke die \"Abfrage Box\" überlagern. Falls Unsere \"Abfrage Box"
"\" wesentlich kleiner als die Gesamtausdehnung der gesamten Geometrietabelle "
"ist, wird dadurch die Anzahl der Entfernungsberechnungen drastisch "
"verringert- dies ist genau das, was wir wollen."

#. Tag: title
#: using_postgis_dataman.xml:2124
#, no-c-format
msgid "Examples of Spatial SQL"
msgstr "Beispiele für Spatial SQL"

#. Tag: para
#: using_postgis_dataman.xml:2126
#, no-c-format
msgid ""
"The examples in this section will make use of two tables, a table of linear "
"roads, and a table of polygonal municipality boundaries. The table "
"definitions for the <varname>bc_roads</varname> table is:"
msgstr ""
"Die Beispiele in diesem Abschnitt verwenden zwei Tabellen, eine Tabelle mit "
"linearen Straßen, und eine Tabelle mit polygonalen Verwaltungsgrenzen. Die "
"Tabellendefinition der Tabelle <varname>bc_roads</varname> lautet:"

#. Tag: programlisting
#: using_postgis_dataman.xml:2130
#, no-c-format
msgid ""
"Column      | Type              | Description\n"
"------------+-------------------+-------------------\n"
"gid         | integer           | Unique ID\n"
"name        | character varying | Road Name\n"
"the_geom    | geometry          | Location Geometry (Linestring)"
msgstr ""
"Column      | Type              | Description\n"
"------------+-------------------+-------------------\n"
"gid         | integer           | Unique ID\n"
"name        | character varying | Road Name\n"
"the_geom    | geometry          | Location Geometry (Linestring)"

#. Tag: para
#: using_postgis_dataman.xml:2132
#, no-c-format
msgid ""
"The table definition for the <varname>bc_municipality</varname> table is:"
msgstr ""
"Die Tabellendefinition für die Tabelle <varname>bc_municipality</varname> "
"lautet:"

#. Tag: programlisting
#: using_postgis_dataman.xml:2135
#, no-c-format
msgid ""
"Column     | Type              | Description\n"
"-----------+-------------------+-------------------\n"
"gid        | integer           | Unique ID\n"
"code       | integer           | Unique ID\n"
"name       | character varying | City / Town Name\n"
"the_geom   | geometry          | Location Geometry (Polygon)"
msgstr ""
"Column     | Type              | Description\n"
"-----------+-------------------+-------------------\n"
"gid        | integer           | Unique ID\n"
"code       | integer           | Unique ID\n"
"name       | character varying | City / Town Name\n"
"the_geom   | geometry          | Location Geometry (Polygon)"

#. Tag: para
#: using_postgis_dataman.xml:2140
#, no-c-format
msgid "What is the total length of all roads, expressed in kilometers?"
msgstr "Gesamtlänge aller Straßen in Kilometer?"

#. Tag: para
#: using_postgis_dataman.xml:2145
#, no-c-format
msgid "You can answer this question with a very simple piece of SQL:"
msgstr ""
"Sie können diese Frage mit einer sehr einfachen SQL Anweisung beantworten:"

#. Tag: programlisting
#: using_postgis_dataman.xml:2148
#, no-c-format
msgid ""
"SELECT sum(ST_Length(the_geom))/1000 AS km_roads FROM bc_roads;\n"
"\n"
"km_roads\n"
"------------------\n"
"70842.1243039643\n"
"(1 row)"
msgstr ""
"SELECT sum(ST_Length(the_geom))/1000 AS km_roads FROM bc_roads;\n"
"\n"
"km_roads\n"
"------------------\n"
"70842.1243039643\n"
"(1 row)"

#. Tag: para
#: using_postgis_dataman.xml:2154
#, no-c-format
msgid "How large is the city of Prince George, in hectares?"
msgstr "Wieviele Hektar hat die Stadt Prince George?"

#. Tag: para
#: using_postgis_dataman.xml:2158
#, no-c-format
msgid ""
"This query combines an attribute condition (on the municipality name) with a "
"spatial calculation (of the area):"
msgstr ""
"Diese Abfrage kombiniert eine Attributbedingung (auf den Gemeindenamen) mit "
"einer räumlichen Berechnung (der Fläche):"

#. Tag: programlisting
#: using_postgis_dataman.xml:2162
#, no-c-format
msgid ""
"SELECT\n"
"  ST_Area(the_geom)/10000 AS hectares\n"
"FROM bc_municipality\n"
"WHERE name = 'PRINCE GEORGE';\n"
"\n"
"hectares\n"
"------------------\n"
"32657.9103824927\n"
"(1 row)"
msgstr ""
"SELECT\n"
"  ST_Area(the_geom)/10000 AS hectares\n"
"FROM bc_municipality\n"
"WHERE name = 'PRINCE GEORGE';\n"
"\n"
"hectares\n"
"------------------\n"
"32657.9103824927\n"
"(1 row)"

#. Tag: para
#: using_postgis_dataman.xml:2168
#, no-c-format
msgid "What is the largest municipality in the province, by area?"
msgstr "Welche ist die flächengrößte Gemeinde der Provinz?"

#. Tag: para
#: using_postgis_dataman.xml:2173
#, no-c-format
msgid ""
"This query brings a spatial measurement into the query condition. There are "
"several ways of approaching this problem, but the most efficient is below:"
msgstr ""
"Diese Abfrage verwendet eine räumliche Messung als Abfragefilter. Es gibt "
"verschiedene Wege dieses Problem anzugehen, aber die effizienteste Methode "
"ist folgende:"

#. Tag: programlisting
#: using_postgis_dataman.xml:2177
#, no-c-format
msgid ""
"SELECT\n"
"  name,\n"
"  ST_Area(the_geom)/10000 AS hectares\n"
"FROM\n"
"  bc_municipality\n"
"ORDER BY hectares DESC\n"
"LIMIT 1;\n"
"\n"
"name           | hectares\n"
"---------------+-----------------\n"
"TUMBLER RIDGE  | 155020.02556131\n"
"(1 row)"
msgstr ""
"SELECT\n"
"  name,\n"
"  ST_Area(the_geom)/10000 AS hectares\n"
"FROM\n"
"  bc_municipality\n"
"ORDER BY hectares DESC\n"
"LIMIT 1;\n"
"\n"
"name           | hectares\n"
"---------------+-----------------\n"
"TUMBLER RIDGE  | 155020.02556131\n"
"(1 row)"

#. Tag: para
#: using_postgis_dataman.xml:2179
#, no-c-format
msgid ""
"Note that in order to answer this query we have to calculate the area of "
"every polygon. If we were doing this a lot it would make sense to add an "
"area column to the table that we could separately index for performance. By "
"ordering the results in a descending direction, and them using the "
"PostgreSQL \"LIMIT\" command we can easily pick off the largest value "
"without using an aggregate function like max()."
msgstr ""
"Um diese Anfrage zu beantworten, müssen wir die Fläche eines jeden Polygons "
"berechnen. Wenn wir dies oft machen müssen, kann es aufgrund der "
"Rechenleistung sinnvoll sein, eine eigene Flächenspalte an die Tabelle "
"anzuhängen und mit einem Index zu versehen. Indem wir das Ergebnis in "
"absteigender Reihenfolge sortieren und den PostgreSQL Befehl \"LIMIT\" "
"einsetzen, können wir die größten Werte herausfiltern, ohne eine "
"Aggregatfunktion wie max() verwenden zu müssen."

#. Tag: para
#: using_postgis_dataman.xml:2191
#, no-c-format
msgid "What is the length of roads fully contained within each municipality?"
msgstr ""
"Welche Länge haben die Straßen, die zur Gänze innerhalb einer Gemeinde "
"liegen?"

#. Tag: para
#: using_postgis_dataman.xml:2196
#, no-c-format
msgid ""
"This is an example of a \"spatial join\", because we are bringing together "
"data from two tables (doing a join) but using a spatial interaction "
"condition (\"contained\") as the join condition rather than the usual "
"relational approach of joining on a common key:"
msgstr ""
"Dies ist ein Beispiel für einen \"Spatial Join\", da wir die Daten aus zwei "
"Tabellen zusammenführen (einen Join ausführen) und als Join-Bedingung eine "
"räumliche Interaktion (\"contained\") verwenden - anstelle  des üblichen "
"relationalen Ansatzes bei dem die Tabellen über einen gemeinsamen Schlüssel "
"verknüpft werden:"

#. Tag: programlisting
#: using_postgis_dataman.xml:2202
#, no-c-format
msgid ""
"SELECT\n"
"  m.name,\n"
"  sum(ST_Length(r.the_geom))/1000 as roads_km\n"
"FROM\n"
"  bc_roads AS r,\n"
"  bc_municipality AS m\n"
"WHERE\n"
"  ST_Contains(m.the_geom, r.the_geom)\n"
"GROUP BY m.name\n"
"ORDER BY roads_km;\n"
"\n"
"name                        | roads_km\n"
"----------------------------+------------------\n"
"SURREY                      | 1539.47553551242\n"
"VANCOUVER                   | 1450.33093486576\n"
"LANGLEY DISTRICT            | 833.793392535662\n"
"BURNABY                     | 773.769091404338\n"
"PRINCE GEORGE               | 694.37554369147\n"
"..."
msgstr ""
"SELECT\n"
"  m.name,\n"
"  sum(ST_Length(r.the_geom))/1000 as roads_km\n"
"FROM\n"
"  bc_roads AS r,\n"
"  bc_municipality AS m\n"
"WHERE\n"
"  ST_Contains(m.the_geom, r.the_geom)\n"
"GROUP BY m.name\n"
"ORDER BY roads_km;\n"
"\n"
"name                        | roads_km\n"
"----------------------------+------------------\n"
"SURREY                      | 1539.47553551242\n"
"VANCOUVER                   | 1450.33093486576\n"
"LANGLEY DISTRICT            | 833.793392535662\n"
"BURNABY                     | 773.769091404338\n"
"PRINCE GEORGE               | 694.37554369147\n"
"..."

#. Tag: para
#: using_postgis_dataman.xml:2204
#, no-c-format
msgid ""
"This query takes a while, because every road in the table is summarized into "
"the final result (about 250K roads for our particular example table). For "
"smaller overlays (several thousand records on several hundred) the response "
"can be very fast."
msgstr ""
"Diese Abfrage dauert ein Weilchen, da sämtliche Straßen in der Tabelle in "
"das endgültige Ergebnis aufsummiert werden müssen (über 250k Straßen in "
"Unserem speziellen Beispiel). Bei kleineren Überlagerungen (ein paar tausend "
"Datensätze auf ein paar Hundert) kann die Antwort sehr schnell zurückkommen."

#. Tag: para
#: using_postgis_dataman.xml:2213
#, no-c-format
msgid "Create a new table with all the roads within the city of Prince George."
msgstr ""
"Eine neue Tabelle erzeugen, die alle Straßen der Stadt Prince George "
"beinhaltet."

#. Tag: para
#: using_postgis_dataman.xml:2218
#, no-c-format
msgid ""
"This is an example of an \"overlay\", which takes in two tables and outputs "
"a new table that consists of spatially clipped or cut resultants. Unlike the "
"\"spatial join\" demonstrated above, this query actually creates new "
"geometries. An overlay is like a turbo-charged spatial join, and is useful "
"for more exact analysis work:"
msgstr ""
"Dies ist ein Beispiel für ein \"Overlay\", das zwei Tabellen entgegennimmt "
"und eine neue Tabelle ausgibt, welche die aus- und abgeschnittene "
"Ergebnisgeometrie enthält. Anders als bei dem oben gezeigten \"Spatial Join"
"\" erzeugt diese Abfrage eine neue Geometrie. Ein \"Overlay\" ist wie ein "
"\"Spatial Join\" mit Turbolader und wird für genauere Analysen verwendet:"

#. Tag: programlisting
#: using_postgis_dataman.xml:2225
#, no-c-format
msgid ""
"CREATE TABLE pg_roads as\n"
"SELECT\n"
"  ST_Intersection(r.the_geom, m.the_geom) AS intersection_geom,\n"
"  ST_Length(r.the_geom) AS rd_orig_length,\n"
"  r.*\n"
"FROM\n"
"  bc_roads AS r,\n"
"  bc_municipality AS m\n"
"WHERE\n"
"  m.name = 'PRINCE GEORGE'\n"
"        AND ST_Intersects(r.the_geom, m.the_geom);"
msgstr ""
"CREATE TABLE pg_roads as\n"
"SELECT\n"
"  ST_Intersection(r.the_geom, m.the_geom) AS intersection_geom,\n"
"  ST_Length(r.the_geom) AS rd_orig_length,\n"
"  r.*\n"
"FROM\n"
"  bc_roads AS r,\n"
"  bc_municipality AS m\n"
"WHERE\n"
"  m.name = 'PRINCE GEORGE'\n"
"        AND ST_Intersects(r.the_geom, m.the_geom);"

#. Tag: para
#: using_postgis_dataman.xml:2231
#, no-c-format
msgid "What is the length in kilometers of \"Douglas St\" in Victoria?"
msgstr "Wie lange ist die \"Douglas St\" in Victoria in Kilometern?"

#. Tag: programlisting
#: using_postgis_dataman.xml:2236
#, no-c-format
msgid ""
"SELECT\n"
"  sum(ST_Length(r.the_geom))/1000 AS kilometers\n"
"FROM\n"
"  bc_roads r,\n"
"  bc_municipality m\n"
"WHERE\n"
"        r.name = 'Douglas St'\n"
"        AND m.name = 'VICTORIA'\n"
"        AND ST_Intersects(m.the_geom, r.the_geom);\n"
"\n"
"kilometers\n"
"------------------\n"
"4.89151904172838\n"
"(1 row)"
msgstr ""
"SELECT\n"
"  sum(ST_Length(r.the_geom))/1000 AS kilometers\n"
"FROM\n"
"  bc_roads r,\n"
"  bc_municipality m\n"
"WHERE\n"
"        r.name = 'Douglas St'\n"
"        AND m.name = 'VICTORIA'\n"
"        AND ST_Intersects(m.the_geom, r.the_geom);\n"
"\n"
"kilometers\n"
"------------------\n"
"4.89151904172838\n"
"(1 row)"

#. Tag: para
#: using_postgis_dataman.xml:2242
#, no-c-format
msgid "What is the largest municipality polygon that has a hole?"
msgstr "Welches ist das größte Gemeindepolygon mit einer Lücke?"

#. Tag: programlisting
#: using_postgis_dataman.xml:2247
#, no-c-format
msgid ""
"SELECT gid, name, ST_Area(the_geom) AS area\n"
"FROM bc_municipality\n"
"WHERE ST_NRings(the_geom) &gt; 1\n"
"ORDER BY area DESC LIMIT 1;\n"
"\n"
"gid  | name         | area\n"
"-----+--------------+------------------\n"
"12   | SPALLUMCHEEN | 257374619.430216\n"
"(1 row)"
msgstr ""
"SELECT gid, name, ST_Area(the_geom) AS area\n"
"FROM bc_municipality\n"
"WHERE ST_NRings(the_geom) &gt; 1\n"
"ORDER BY area DESC LIMIT 1;\n"
"\n"
"gid  | name         | area\n"
"-----+--------------+------------------\n"
"12   | SPALLUMCHEEN | 257374619.430216\n"
"(1 row)"
